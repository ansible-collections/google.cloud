#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2017-2026 Google
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
# ----------------------------------------------------------------------------
#

from __future__ import absolute_import, division, print_function

__metaclass__ = type

################################################################################
# Documentation
################################################################################

ANSIBLE_METADATA = {
    "metadata_version": "1.1",
    "status": ["preview"],
    "supported_by": "community",
}

DOCUMENTATION = r"""
---
author:
  - Google Inc. (@googlecloudplatform)
description:
  - An endpoint indexes are deployed into. An index endpoint can have multiple deployed indexes.
extends_documentation_fragment:
  - google.cloud.gcp
module: gcp_vertexai_index_endpoint_deployed_index
notes:
  - 'API Reference: U(https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex)'
options:
  automatic_resources:
    description:
      - >-
        A description of resources that the DeployedIndex uses, which to large degree are decided by Vertex AI, and optionally allows only a modest

        additional configuration.
    suboptions:
      max_replica_count:
        description:
          - The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases.
          - If maxReplicaCount is not set, the default value is minReplicaCount.
          - The max allowed replica count is 1000.
          - The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases.
          - >-
            If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many

            replicas is guaranteed (barring service outages).
          - If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped.
          - >-
            If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale

            beyond certain replica number.
        type: int
      min_replica_count:
        description:
          - The minimum number of replicas this DeployedModel will be always deployed on.
          - If minReplicaCount is not set, the default value is 2 (we don't provide SLA when minReplicaCount=1).
          - >-
            If traffic against it increases, it may dynamically be deployed onto more replicas up to

            [maxReplicaCount](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/AutomaticResources#FIELDS.max_replica_count), and as traffic

            decreases, some of these extra replicas may be freed.
          - If the requested value is too large, the deployment will error.
        type: int
    type: dict
  dedicated_resources:
    description:
      - A description of resources that are dedicated to the DeployedIndex, and that need a higher degree of manual configuration.
      - The field minReplicaCount must be set to a value strictly greater than 0, or else validation will fail.
      - We don't provide SLA when minReplicaCount=1.
      - If maxReplicaCount is not set, the default value is minReplicaCount.
      - The max allowed replica count is 1000.
      - 'Available machine types for SMALL shard: e2-standard-2 and all machine types available for MEDIUM and LARGE shard.'
      - 'Available machine types for MEDIUM shard: e2-standard-16 and all machine types available for LARGE shard.'
      - 'Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.'
      - n1-standard-16 and n1-standard-32 are still available, but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
    suboptions:
      machine_spec:
        description:
          - The minimum number of replicas this DeployedModel will be always deployed on.
        required: true
        suboptions:
          machine_type:
            description:
              - The type of the machine.
              - >-
                See the [list of machine types supported for

                prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported

                for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
              - >-
                For [DeployedModel](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.endpoints#DeployedModel) this field is

                optional, and the default value is n1-standard-2.
              - >-
                For

                [BatchPredictionJob](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.batchPredictionJobs#BatchPredictionJob) or

                as part of [WorkerPoolSpec](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/CustomJobSpec#WorkerPoolSpec) this field is required.
            type: str
        type: dict
      max_replica_count:
        description:
          - The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases.
          - If maxReplicaCount is not set, the default value is minReplicaCount.
        type: int
      min_replica_count:
        description:
          - The minimum number of machine replicas this DeployedModel will be always deployed on.
          - This value must be greater than or equal to 1.
        required: true
        type: int
    type: dict
  deployed_index_auth_config:
    description:
      - If set, the authentication is enabled for the private endpoint.
    suboptions:
      auth_provider:
        description:
          - Defines the authentication provider that the DeployedIndex uses.
        suboptions:
          allowed_issuers:
            description:
              - A list of allowed JWT issuers.
              - 'Each entry must be a valid Google service account, in the following format: service-account-name@project-id.iam.gserviceaccount.com.'
            elements: str
            type: list
          audiences:
            description:
              - The list of JWT audiences.
              - that are allowed to access.
              - A JWT containing any of these audiences will be accepted.
            elements: str
            type: list
        type: dict
    type: dict
  deployed_index_id:
    description:
      - The user specified ID of the DeployedIndex.
      - The ID can be up to 128 characters long and must start with a letter and only contain letters, numbers, and underscores.
      - The ID must be unique within the project it is created in.
    required: true
    type: str
  deployment_group:
    default: default
    description:
      - 'The deployment group can be no longer than 64 characters (eg: ''test'', ''prod'').'
      - If not set, we will use the 'default' deployment group.
      - Creating deployment_groups with reserved_ip_ranges is a recommended practice when the peered network has multiple peering ranges.
      - This creates your deployments from predictable IP spaces for easier traffic administration.
      - >-
        Also, one deployment_group (except 'default') can only be used with the same reserved_ip_ranges which means if the deployment_group has been

        used with reserved_ip_ranges: [a, b, c], using it with [a, b] or [d, e] is disallowed.
      - >-
        [See the official documentation

        here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#DeployedIndex.FIELDS.deployment_group).
      - 'Note: we only support up to 5 deployment groups (not including ''default'').'
    type: str
  display_name:
    description:
      - The display name of the Index.
      - The name can be up to 128 characters long and can consist of any UTF-8 characters.
    type: str
  enable_access_logging:
    default: false
    description:
      - If true, private endpoint's access logs are sent to Cloud Logging.
    type: bool
  index:
    description:
      - The name of the Index this is the deployment of.
    required: true
    type: str
  index_endpoint:
    description:
      - Identifies the index endpoint.
      - Must be in the format 'projects/{{project}}/locations/{{region}}/indexEndpoints/{{indexEndpoint}}'.
      - This field is a reference to a IndexEndpoint resource in GCP.
      - 'It can be specified in two ways: First, you can place a dictionary with key ''name'' matching your resource.'
      - 'Alternatively, you can add `register: name-of-resource` to a IndexEndpoint task and then set this field to `{{ name-of-resource }}`.'
    required: true
    type: dict
  region:
    description:
      - The region of the index.
      - eg us-central1.
    required: true
    type: str
  reserved_ip_ranges:
    description:
      - A list of reserved ip ranges under the VPC network that can be used for this DeployedIndex.
      - If set, we will deploy the index within the provided ip ranges.
      - Otherwise, the index might be deployed to any ip ranges under the provided VPC network.
      - >-
        The value should be the name of the address (https://cloud.google.com/compute/docs/reference/rest/v1/addresses) Example:

        ['vertex-ai-ip-range'].
      - >-
        For more information about subnets and network IP ranges, please see

        https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
    elements: str
    type: list
  state:
    choices:
      - present
      - absent
    default: present
    description:
      - Whether the resource should exist in GCP.
    type: str
requirements:
  - python >= 3.8
  - requests >= 2.18.4
  - google-auth >= 2.25.1
short_description: Creates a GCP VertexAI.IndexEndpointDeployedIndex resource
"""

EXAMPLES = r"""
- name: Create basic index endpoint deployed index
  google.cloud.gcp_vertexai_index_endpoint_deployed_index:
    state: present
    display_name: "{{ resource_name }}"
    deployed_index_id: "{{ resource_name | regex_replace('-', '_') }}"
    region: us-central1
    index: "{{ _myidx.name }}"
    index_endpoint: "{{ _myidxep.name }}"
    enable_access_logging: false
    deployed_index_auth_config:
      auth_provider:
        audiences:
          - 123-myapp
        allowed_issuers:
          - mysa@myproject.iam.gserviceaccount.com
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"

################################################################################

- name: Create index endpoint deployed index with dedicated resources
  google.cloud.gcp_vertexai_index_endpoint_deployed_index:
    state: present
    display_name: "{{ resource_name }}"
    deployed_index_id: "{{ resource_name | regex_replace('-', '_') }}"
    region: us-central1
    index: "{{ _myidx.name }}"
    index_endpoint: "{{ _myidxep.name }}"
    enable_access_logging: false
    deployed_index_auth_config:
      auth_provider:
        audiences:
          - 123-myapp
        allowed_issuers:
          - mysa@myproject.iam.gserviceaccount.com
    dedicated_resources:
      min_replica_count: 1
      max_replica_count: 3
      machine_spec:
        machine_type: e2-standard-2
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"

################################################################################

- name: Create index endpoint deployed index with automatic resources
  google.cloud.gcp_vertexai_index_endpoint_deployed_index:
    state: present
    display_name: "{{ resource_name }}"
    deployed_index_id: "{{ resource_name | regex_replace('-', '_') }}"
    region: us-central1
    index: "{{ _myidx.name }}"
    index_endpoint: "{{ _myidxep.name }}"
    enable_access_logging: false
    deployed_index_auth_config:
      auth_provider:
        audiences:
          - 123-myapp
        allowed_issuers:
          - mysa@myproject.iam.gserviceaccount.com
    automatic_resources:
      max_replica_count: 3
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"
"""

RETURN = r"""
changed:
  description: Whether the resource was changed.
  returned: always
  type: bool
createTime:
  description:
    - The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
  returned: success
  type: str
indexSyncTime:
  description:
    - The DeployedIndex may depend on various data on its original Index.
    - Additionally when certain changes to the original Index are being done (e.g.
    - when what the Index contains is being changed) the DeployedIndex may be asynchronously updated in the background to reflect these changes.
    - >-
      If this timestamp's value is at least the

      [Index.update_time](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes#Index.FIELDS.update_time) of the

      original Index, it means that this DeployedIndex and the original Index are in sync.
    - >-
      If this timestamp is older, then to see which updates this DeployedIndex already contains (and which it does not), one must

      [list](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.operations/list#google.longrunning.Operations.ListOperations)

      the operations that are running on the original Index.
    - Only the successfully completed Operations with updateTime equal or before this sync time are contained in this DeployedIndex.
    - A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
    - Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
  returned: success
  type: str
name:
  description:
    - The name of the DeployedIndex resource.
  returned: success
  type: str
privateEndpoints:
  contains:
    matchGrpcAddress:
      description:
        - The ip address used to send match gRPC requests.
      returned: success
      type: str
    pscAutomatedEndpoints:
      contains:
        matchAddress:
          description:
            - ip Address created by the automated forwarding rule.
          returned: success
          type: str
        network:
          description:
            - Corresponding network in pscAutomationConfigs.
          returned: success
          type: str
        projectId:
          description:
            - Corresponding projectId in pscAutomationConfigs.
          returned: success
          type: str
      description:
        - PscAutomatedEndpoints is populated if private service connect is enabled if PscAutomatedConfig is set.
      elements: dict
      returned: success
      type: list
    serviceAttachment:
      description:
        - The name of the service attachment resource.
        - Populated if private service connect is enabled.
      returned: success
      type: str
  description:
    - Provides paths for users to send requests directly to the deployed index services running on Cloud via private services access.
    - >-
      This field is populated if

      [network](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints#IndexEndpoint.FIELDS.network) is

      configured.
  returned: success
  type: dict
state:
  description: The current state of the resource.
  returned: always
  type: str
"""

################################################################################
# Imports
################################################################################

from ansible_collections.google.cloud.plugins.module_utils import gcp_utils as gcp
import types

# BEGIN Custom imports
import copy

# END Custom imports


def build_link(module_params, uri):
    params = module_params.copy()
    params["index_endpoint"] = gcp.replace_resource_dict(module_params["index_endpoint"], "name")

    return ("https://{region}-aiplatform.googleapis.com/v1/" + uri).format(**params)


class AutomaticResources(gcp.Resource):
    def _request(self):
        return {
            "maxReplicaCount": self.request.get("max_replica_count"),
            "minReplicaCount": self.request.get("min_replica_count"),
        }

    def _response(self):
        return {
            "maxReplicaCount": self.response.get("maxReplicaCount"),
            "minReplicaCount": self.response.get("minReplicaCount"),
        }


class DedicatedResources(gcp.Resource):
    def _request(self):
        return {
            "machineSpec": gcp.remove_empties(
                DedicatedResourcesMachineSpec(self.request.get("machine_spec", {})).to_request()
            ),  # remove empty values
            "maxReplicaCount": self.request.get("max_replica_count"),
            "minReplicaCount": self.request.get("min_replica_count"),
        }

    def _response(self):
        return {
            "machineSpec": DedicatedResourcesMachineSpec().from_response(self.response.get("machineSpec", {})),
            "maxReplicaCount": self.response.get("maxReplicaCount"),
            "minReplicaCount": self.response.get("minReplicaCount"),
        }


class DedicatedResourcesMachineSpec(gcp.Resource):
    def _request(self):
        return {
            "machineType": self.request.get("machine_type"),
        }

    def _response(self):
        return {
            "machineType": self.response.get("machineType"),
        }


class DeployedIndexAuthConfig(gcp.Resource):
    def _request(self):
        return {
            "authProvider": gcp.remove_empties(
                DeployedIndexAuthConfigAuthProvider(self.request.get("auth_provider", {})).to_request()
            ),  # remove empty values
        }

    def _response(self):
        return {
            "authProvider": DeployedIndexAuthConfigAuthProvider().from_response(self.response.get("authProvider", {})),
        }


class DeployedIndexAuthConfigAuthProvider(gcp.Resource):
    def _request(self):
        return {
            "allowedIssuers": self.request.get("allowed_issuers"),
            "audiences": self.request.get("audiences"),
        }

    def _response(self):
        return {
            "allowedIssuers": self.response.get("allowedIssuers"),
            "audiences": self.response.get("audiences"),
        }


class PrivateEndpoints(gcp.Resource):
    def _response(self):
        return {
            "matchGrpcAddress": self.response.get("matchGrpcAddress"),
            "pscAutomatedEndpoints": [
                PrivateEndpointsPscAutomatedEndpoint().from_response(item)
                for item in (self.response.get("pscAutomatedEndpoints") or [])
            ],
            "serviceAttachment": self.response.get("serviceAttachment"),
        }


class PrivateEndpointsPscAutomatedEndpoint(gcp.Resource):
    def _response(self):
        return {
            "matchAddress": self.response.get("matchAddress"),
            "network": self.response.get("network"),
            "projectId": self.response.get("projectId"),
        }


class VertexAI(gcp.Resource):
    def _request(self):
        return {
            "automaticResources": gcp.remove_empties(
                AutomaticResources(self.request.get("automatic_resources", {})).to_request()
            ),  # remove empty values
            "dedicatedResources": gcp.remove_empties(
                DedicatedResources(self.request.get("dedicated_resources", {})).to_request()
            ),  # remove empty values
            "deployedIndexAuthConfig": gcp.remove_empties(
                DeployedIndexAuthConfig(self.request.get("deployed_index_auth_config", {})).to_request()
            ),  # remove empty values
            "deployedIndexId": self.request.get("deployed_index_id"),
            "deploymentGroup": self.request.get("deployment_group"),
            "displayName": self.request.get("display_name"),
            "enableAccessLogging": self.request.get("enable_access_logging"),
            "index": self.request.get("index"),
            "reservedIpRanges": [str(item) for item in (self.request.get("reserved_ip_ranges") or [])],
        }

    def _response(self):
        return {
            "automaticResources": AutomaticResources().from_response(self.response.get("automaticResources", {})),
            "createTime": self.response.get("createTime"),
            "dedicatedResources": DedicatedResources().from_response(self.response.get("dedicatedResources", {})),
            "deployedIndexAuthConfig": DeployedIndexAuthConfig().from_response(
                self.response.get("deployedIndexAuthConfig", {})
            ),
            "deployedIndexId": self.response.get("deployedIndexId"),
            "deploymentGroup": self.response.get("deploymentGroup"),
            "displayName": self.response.get("displayName"),
            "enableAccessLogging": self.response.get("enableAccessLogging"),
            "index": self.response.get("index"),
            "indexSyncTime": self.response.get("indexSyncTime"),
            "name": self.response.get("name"),
            "privateEndpoints": PrivateEndpoints().from_response(self.response.get("privateEndpoints", {})),
            "reservedIpRanges": [str(item) for item in (self.response.get("reservedIpRanges") or [])],
        }


################################################################################
# Main
################################################################################


def encode(self, obj):
    """
    This is a function bound to the main resource object. Its input is the object returned from to_request()
    and it mutates it before it is sent to the API.
    """
    # --------- BEGIN custom encoder code ---------
    r = {}
    action = getattr(self, "_action", "read")
    self.debug(func="encoder", action=action, obj=obj)
    if action == "read":  # for read, we just return the original object
        r = copy.deepcopy(obj)
    elif action == "create":  # encode for create
        # deployIndex requires the deployedIndex in a nested object
        # https://docs.cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints/deployIndex#request-body
        t = copy.deepcopy(obj)
        t["id"] = t.pop("deployedIndexId")
        r = {"deployedIndex": t}
    elif action == "update":  # encode for update
        # mutateDeployedIndex requires the deployedIndex definition at top-level
        # https://docs.cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints/mutateDeployedIndex#request-body
        r = copy.deepcopy(obj)
        r["id"] = r.pop("deployedIndexId")
    else:  # encode for delete
        # normally, deletes are empty but undeployIndex requires a single parameter, the deployedIndexId
        # https://docs.cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexEndpoints/undeployIndex#request-body
        r = {"deployedIndexId": self._request().get("deployedIndexId")}

    return r

    # --------- END custom encoder code ---------


def decode(self, obj):
    """
    This is a function bound to the main resource object. Its input is the object returned from from_response()
    and it mutates it before it is returned to the module caller.
    """
    # --------- BEGIN custom decoder code ---------
    r = copy.deepcopy(obj)
    deployed_index = r.pop("deployedIndex", None)
    if deployed_index is not None:
        r["deployedIndexId"] = deployed_index.pop("id", None)
    elif r.get("id") is not None:
        r["deployedIndexId"] = r.pop("id")
    else:
        pass
    return r

    # --------- END custom decoder code ---------


def main():
    """Main function"""

    module = gcp.Module(
        argument_spec=dict(
            state=dict(
                type="str",
                default="present",
                choices=["present", "absent"],
            ),
            automatic_resources=dict(
                type="dict",
                options=dict(
                    max_replica_count=dict(
                        type="int",
                    ),
                    min_replica_count=dict(
                        type="int",
                    ),
                ),
            ),
            dedicated_resources=dict(
                type="dict",
                options=dict(
                    machine_spec=dict(
                        type="dict",
                        required=True,
                        options=dict(
                            machine_type=dict(
                                type="str",
                            )
                        ),
                    ),
                    max_replica_count=dict(
                        type="int",
                    ),
                    min_replica_count=dict(
                        type="int",
                        required=True,
                    ),
                ),
            ),
            deployed_index_auth_config=dict(
                type="dict",
                no_log=False,
                options=dict(
                    auth_provider=dict(
                        type="dict",
                        no_log=False,
                        options=dict(
                            allowed_issuers=dict(
                                type="list",
                                elements="str",
                            ),
                            audiences=dict(
                                type="list",
                                elements="str",
                            ),
                        ),
                    )
                ),
            ),
            deployed_index_id=dict(
                type="str",
                required=True,
            ),
            deployment_group=dict(
                type="str",
                default="default",
            ),
            display_name=dict(
                type="str",
            ),
            enable_access_logging=dict(
                type="bool",
                default=False,
            ),
            index=dict(
                type="str",
                required=True,
            ),
            index_endpoint=dict(
                type="dict",
                required=True,
            ),
            region=dict(
                type="str",
                required=True,
            ),
            reserved_ip_ranges=dict(
                type="list",
                elements="str",
            ),
        )
    )

    if not module.params["scopes"]:
        module.params["scopes"] = ["https://www.googleapis.com/auth/cloud-platform"]

    state = module.params["state"]
    changed = False
    op_configs = gcp.ResourceOpConfigs(
        {
            "base_url": gcp.ResourceOpConfig(
                **{"uri": "{index_endpoint}", "async_uri": "", "verb": "GET", "timeout_minutes": 0}
            ),
            "create": gcp.ResourceOpConfig(
                **{"uri": "{index_endpoint}:deployIndex", "async_uri": "{op_id}", "verb": "POST", "timeout_minutes": 45}
            ),
            "delete": gcp.ResourceOpConfig(
                **{
                    "uri": "{index_endpoint}:undeployIndex",
                    "async_uri": "{op_id}",
                    "verb": "POST",
                    "timeout_minutes": 20,
                }
            ),
            "read": gcp.ResourceOpConfig(
                **{"uri": "{index_endpoint}", "async_uri": "", "verb": "GET", "timeout_minutes": 0}
            ),
            "update": gcp.ResourceOpConfig(
                **{
                    "uri": "{index_endpoint}:mutateDeployedIndex",
                    "async_uri": "{op_id}",
                    "verb": "POST",
                    "timeout_minutes": 45,
                }
            ),
        }
    )

    params = gcp.remove_nones(module.params)
    resource = VertexAI(params, module=module, product="VertexAI", kind="vertexai#indexEndpointDeployedIndex")
    read_uri = op_configs.read.uri

    resource._state = state  # store the state in the resource object
    # Bind the encode and decode functions to the resource object
    resource.encode_func = types.MethodType(encode, resource)
    resource.decode_func = types.MethodType(decode, resource)

    custom_diff = None  # Set this variable if you want to implement custom diff logic

    # --------- BEGIN pre-read custom code ---------
    resource._action = "read"

    # --------- END pre-read custom code ---------

    read_url = build_link(params, read_uri)
    existing_obj = resource.get(read_url, allow_not_found=True) or {}
    new_obj = {}
    gcp.debug(module, existing=existing_obj, post=False)

    # --------- BEGIN post-read custom code ---------
    # We need an existing index endpoint to work with
    if gcp.empty(existing_obj):
        module.fail_json(msg="The referenced index endpoint was not found")
    else:
        for didx in existing_obj.get("deployedIndexes", []):
            if didx.get("id") == params.get("deployed_index_id"):
                existing_obj = didx
                break
        else:  # deployedIndexes was empty or no match found
            existing_obj = {}
    # --------- END post-read custom code ---------

    if custom_diff is not None:
        is_different = custom_diff
    else:
        is_different = resource.diff(gcp.remove_empties(existing_obj))
    gcp.debug(
        module,
        request=gcp.remove_empties(resource.to_request()),
        existing=existing_obj,
        post=True,
        is_different=is_different,
    )

    if gcp.empty(existing_obj):
        if state == "present":
            create_uri = op_configs.create.uri
            create_async_uri = op_configs.create.async_uri
            try:
                # --------- BEGIN create code ---------
                # --------- BEGIN pre-create custom code ---------
                resource._action = "create"

                # --------- END pre-create custom code ---------
                is_async = create_async_uri != ""
                create_link = build_link(params, create_uri)
                create_retries = op_configs.create.timeout
                create_func = getattr(resource, op_configs.create.verb)
                async_create_func = getattr(resource, op_configs.create.verb + "_async")
                async_create_link = build_link(params, "") + create_async_uri
                gcp.debug(
                    module,
                    msg="Creating resource",
                    create_link=create_link,
                    async_create_link=async_create_link,
                    is_async=is_async,
                )

                if is_async:
                    new_obj = async_create_func(create_link, async_link=async_create_link, retries=create_retries)
                else:
                    new_obj = create_func(create_link)
                gcp.debug(module, new=new_obj, action="create", post=False)
                gcp.debug(module, new=new_obj, action="create", post=True)
                # --------- END create code ---------
            except Exception as e:
                module.fail_json(msg=str(e))

            changed = True
        else:
            pass  # nothing to do
    else:
        if state == "absent":
            delete_uri = op_configs.delete.uri
            delete_async_uri = op_configs.delete.async_uri
            try:
                # --------- BEGIN delete code ---------
                # --------- BEGIN pre-delete custom code ---------
                resource._action = "delete"

                # --------- END pre-delete custom code ---------
                is_async = delete_async_uri != ""
                delete_link = build_link(params, delete_uri)
                delete_retries = op_configs.delete.timeout
                delete_func = getattr(resource, op_configs.delete.verb)
                async_delete_func = getattr(resource, op_configs.delete.verb + "_async")
                async_delete_link = build_link(params, "") + delete_async_uri
                gcp.debug(
                    module,
                    msg="Destroying resource",
                    delete_link=delete_link,
                    async_delete_link=async_delete_link,
                    is_async=is_async,
                )
                if is_async:
                    new_obj = async_delete_func(delete_link, async_link=async_delete_link, retries=delete_retries)
                else:
                    new_obj = delete_func(delete_link)
                # --------- END delete code ---------
            except Exception as e:
                module.fail_json(msg=str(e))

            changed = True
        else:
            if is_different:
                update_uri = op_configs.update.uri
                update_async_uri = op_configs.update.async_uri
                try:
                    # --------- BEGIN update code ---------
                    # --------- BEGIN pre-update custom code ---------
                    resource._action = "update"

                    # --------- END pre-update custom code ---------
                    is_async = update_async_uri != ""
                    update_link = build_link(params, update_uri)
                    update_retries = op_configs.update.timeout
                    update_func = getattr(resource, op_configs.update.verb)
                    async_update_func = getattr(resource, op_configs.update.verb + "_async")
                    async_update_link = build_link(params, "") + update_async_uri
                    gcp.debug(
                        module,
                        msg="Updating resource",
                        update_link=update_link,
                        async_update_link=async_update_link,
                        is_async=is_async,
                    )
                    if is_async:
                        new_obj = async_update_func(update_link, async_link=async_update_link, retries=update_retries)
                    else:
                        new_obj = update_func(update_link)
                    gcp.debug(module, new=new_obj, action="update", post=False)
                    gcp.debug(module, new=new_obj, action="update", post=True)
                    # --------- END update code ---------
                except Exception as e:
                    module.fail_json(msg=str(e))

                changed = True
            else:
                new_obj = existing_obj

    new_obj.update({"changed": changed})
    module.exit_json(**new_obj)


if __name__ == "__main__":
    main()
