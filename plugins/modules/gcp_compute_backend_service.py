#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2017 Google
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
#     Please read more about how to change this file at
#     https://www.github.com/GoogleCloudPlatform/magic-modules
#
# ----------------------------------------------------------------------------

from __future__ import absolute_import, division, print_function

__metaclass__ = type

################################################################################
# Documentation
################################################################################

ANSIBLE_METADATA = {
    "metadata_version": "1.1",
    "status": ["preview"],
    "supported_by": "community",
}

DOCUMENTATION = """
---
module: gcp_compute_backend_service
description:
- A Backend Service defines a group of virtual machines that will serve traffic for
  load balancing. This resource is a global backend service, appropriate for external
  load balancing or self-managed internal load balancing.
- For managed internal load balancing, use a regional backend service instead.
- Currently self-managed internal load balancing is only available in beta.
short_description: Creates a GCP BackendService
author: Google Inc. (@googlecloudplatform)
requirements:
- python >= 2.6
- requests >= 2.18.4
- google-auth >= 1.3.0
options:
  state:
    description:
    - Whether the given object should exist in GCP
    choices:
    - present
    - absent
    default: present
    type: str
  affinity_cookie_ttl_sec:
    description:
    - Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set
      to 0, the cookie is non-persistent and lasts only until the end of the browser
      session (or equivalent). The maximum allowed value for TTL is one day.
    - When the load balancing scheme is INTERNAL, this field is not used.
    required: false
    type: int
  backends:
    description:
    - The set of backends that serve this BackendService.
    elements: dict
    required: false
    type: list
    suboptions:
      balancing_mode:
        description:
        - Specifies the balancing mode for this backend.
        - For global HTTP(S) or TCP/SSL load balancing, the default is UTILIZATION.
          Valid values are UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).
        - 'Some valid choices include: "UTILIZATION", "RATE", "CONNECTION"'
        required: false
        default: UTILIZATION
        type: str
      capacity_scaler:
        description:
        - A multiplier applied to the group's maximum servicing capacity (based on
          UTILIZATION, RATE or CONNECTION).
        - Default value is 1, which means the group will serve up to 100% of its configured
          capacity (depending on balancingMode). A setting of 0 means the group is
          completely drained, offering 0% of its available Capacity. Valid range is
          [0.0,1.0].
        required: false
        default: '1.0'
        type: str
      description:
        description:
        - An optional description of this resource.
        - Provide this property when you create the resource.
        required: false
        type: str
      group:
        description:
        - The fully-qualified URL of an Instance Group or Network Endpoint Group resource.
          In case of instance group this defines the list of instances that serve
          traffic. Member virtual machine instances from each instance group must
          live in the same zone as the instance group itself. No two backends in a
          backend service are allowed to use same Instance Group resource.
        - For Network Endpoint Groups this defines list of endpoints. All endpoints
          of Network Endpoint Group must be hosted on instances located in the same
          zone as the Network Endpoint Group.
        - Backend services cannot mix Instance Group and Network Endpoint Group backends.
        - Note that you must specify an Instance Group or Network Endpoint Group resource
          using the fully-qualified URL, rather than a partial URL.
        required: true
        type: str
      max_connections:
        description:
        - The max number of simultaneous connections for the group. Can be used with
          either CONNECTION or UTILIZATION balancing modes.
        - For CONNECTION mode, either maxConnections or one of maxConnectionsPerInstance
          or maxConnectionsPerEndpoint, as appropriate for group type, must be set.
        required: false
        type: int
      max_connections_per_instance:
        description:
        - The max number of simultaneous connections that a single backend instance
          can handle. This is used to calculate the capacity of the group. Can be
          used in either CONNECTION or UTILIZATION balancing modes.
        - For CONNECTION mode, either maxConnections or maxConnectionsPerInstance
          must be set.
        required: false
        type: int
      max_connections_per_endpoint:
        description:
        - The max number of simultaneous connections that a single backend network
          endpoint can handle. This is used to calculate the capacity of the group.
          Can be used in either CONNECTION or UTILIZATION balancing modes.
        - For CONNECTION mode, either maxConnections or maxConnectionsPerEndpoint
          must be set.
        required: false
        type: int
      max_rate:
        description:
        - The max requests per second (RPS) of the group.
        - Can be used with either RATE or UTILIZATION balancing modes, but required
          if RATE mode. For RATE mode, either maxRate or one of maxRatePerInstance
          or maxRatePerEndpoint, as appropriate for group type, must be set.
        required: false
        type: int
      max_rate_per_instance:
        description:
        - The max requests per second (RPS) that a single backend instance can handle.
          This is used to calculate the capacity of the group. Can be used in either
          balancing mode. For RATE mode, either maxRate or maxRatePerInstance must
          be set.
        required: false
        type: str
      max_rate_per_endpoint:
        description:
        - The max requests per second (RPS) that a single backend network endpoint
          can handle. This is used to calculate the capacity of the group. Can be
          used in either balancing mode. For RATE mode, either maxRate or maxRatePerEndpoint
          must be set.
        required: false
        type: str
      max_utilization:
        description:
        - Used when balancingMode is UTILIZATION. This ratio defines the CPU utilization
          target for the group. Valid range is [0.0, 1.0].
        required: false
        type: str
  circuit_breakers:
    description:
    - Settings controlling the volume of connections to a backend service. This field
      is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
    required: false
    type: dict
    suboptions:
      max_requests_per_connection:
        description:
        - Maximum requests for a single backend connection. This parameter is respected
          by both the HTTP/1.1 and HTTP/2 implementations. If not specified, there
          is no limit. Setting this parameter to 1 will effectively disable keep alive.
        required: false
        type: int
      max_connections:
        description:
        - The maximum number of connections to the backend cluster.
        - Defaults to 1024.
        required: false
        default: '1024'
        type: int
      max_pending_requests:
        description:
        - The maximum number of pending requests to the backend cluster.
        - Defaults to 1024.
        required: false
        default: '1024'
        type: int
      max_requests:
        description:
        - The maximum number of parallel requests to the backend cluster.
        - Defaults to 1024.
        required: false
        default: '1024'
        type: int
      max_retries:
        description:
        - The maximum number of parallel retries to the backend cluster.
        - Defaults to 3.
        required: false
        default: '3'
        type: int
  consistent_hash:
    description:
    - Consistent Hash-based load balancing can be used to provide soft session affinity
      based on HTTP headers, cookies or other properties. This load balancing policy
      is applicable only for HTTP connections. The affinity to a particular destination
      host will be lost when one or more hosts are added/removed from the destination
      service. This field specifies parameters that control consistent hashing. This
      field only applies if the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
      This field is only applicable when locality_lb_policy is set to MAGLEV or RING_HASH.
    required: false
    type: dict
    suboptions:
      http_cookie:
        description:
        - Hash is based on HTTP Cookie. This field describes a HTTP cookie that will
          be used as the hash key for the consistent hash load balancer. If the cookie
          is not present, it will be generated.
        - This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
        required: false
        type: dict
        suboptions:
          ttl:
            description:
            - Lifetime of the cookie.
            required: false
            type: dict
            suboptions:
              seconds:
                description:
                - Span of time at a resolution of a second.
                - Must be from 0 to 315,576,000,000 inclusive.
                required: true
                type: int
              nanos:
                description:
                - Span of time that's a fraction of a second at nanosecond resolution.
                  Durations less than one second are represented with a 0 seconds
                  field and a positive nanos field. Must be from 0 to 999,999,999
                  inclusive.
                required: false
                type: int
          name:
            description:
            - Name of the cookie.
            required: false
            type: str
          path:
            description:
            - Path to set for the cookie.
            required: false
            type: str
      http_header_name:
        description:
        - The hash based on the value of the specified header field.
        - This field is applicable if the sessionAffinity is set to HEADER_FIELD.
        required: false
        type: str
      minimum_ring_size:
        description:
        - The minimum number of virtual nodes to use for the hash ring.
        - Larger ring sizes result in more granular load distributions. If the number
          of hosts in the load balancing pool is larger than the ring size, each host
          will be assigned a single virtual node.
        - Defaults to 1024.
        required: false
        default: '1024'
        type: int
  cdn_policy:
    description:
    - Cloud CDN configuration for this BackendService.
    required: false
    type: dict
    suboptions:
      cache_key_policy:
        description:
        - The CacheKeyPolicy for this CdnPolicy.
        required: false
        type: dict
        suboptions:
          include_host:
            description:
            - If true requests to different hosts will be cached separately.
            required: false
            type: bool
          include_protocol:
            description:
            - If true, http and https requests will be cached separately.
            required: false
            type: bool
          include_query_string:
            description:
            - If true, include query string parameters in the cache key according
              to query_string_whitelist and query_string_blacklist. If neither is
              set, the entire query string will be included.
            - If false, the query string will be excluded from the cache key entirely.
            required: false
            type: bool
          query_string_blacklist:
            description:
            - Names of query string parameters to exclude in cache keys.
            - All other parameters will be included. Either specify query_string_whitelist
              or query_string_blacklist, not both.
            - "'&' and '=' will be percent encoded and not treated as delimiters."
            elements: str
            required: false
            type: list
          query_string_whitelist:
            description:
            - Names of query string parameters to include in cache keys.
            - All other parameters will be excluded. Either specify query_string_whitelist
              or query_string_blacklist, not both.
            - "'&' and '=' will be percent encoded and not treated as delimiters."
            elements: str
            required: false
            type: list
      signed_url_cache_max_age_sec:
        description:
        - Maximum number of seconds the response to a signed URL request will be considered
          fresh, defaults to 1hr (3600s). After this time period, the response will
          be revalidated before being served.
        - 'When serving responses to signed URL requests, Cloud CDN will internally
          behave as though all responses from this backend had a "Cache-Control: public,
          max-age=[TTL]" header, regardless of any existing Cache-Control header.
          The actual headers served in responses will not be altered.'
        required: false
        default: '3600'
        type: int
      default_ttl:
        description:
        - Specifies the default TTL for cached content served by this origin for responses
          that do not have an existing valid TTL (max-age or s-max-age).
        required: false
        type: int
      max_ttl:
        description:
        - Specifies the maximum allowed TTL for cached content served by this origin.
        required: false
        type: int
      client_ttl:
        description:
        - Specifies the maximum allowed TTL for cached content served by this origin.
        required: false
        type: int
      negative_caching:
        description:
        - Negative caching allows per-status code TTLs to be set, in order to apply
          fine-grained caching for common errors or redirects.
        required: false
        type: bool
      negative_caching_policy:
        description:
        - Sets a cache TTL for the specified HTTP status code. negativeCaching must
          be enabled to configure negativeCachingPolicy.
        - Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's
          default cache TTLs.
        elements: dict
        required: false
        type: list
        suboptions:
          code:
            description:
            - The HTTP status code to define a TTL against. Only HTTP status codes
              300, 301, 308, 404, 405, 410, 421, 451 and 501 can be specified as values,
              and you cannot specify a status code more than once.
            required: false
            type: int
          ttl:
            description:
            - The TTL (in seconds) for which to cache responses with the corresponding
              status code. The maximum allowed value is 1800s (30 minutes), noting
              that infrequently accessed objects may be evicted from the cache before
              the defined TTL.
            required: false
            type: int
      cache_mode:
        description:
        - Specifies the cache setting for all responses from this backend.
        - 'The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
          .'
        - 'Some valid choices include: "USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"'
        required: false
        type: str
      serve_while_stale:
        description:
        - Serve existing content from the cache (if available) when revalidating content
          with the origin, or when an error is encountered when refreshing the cache.
        required: false
        type: int
  connection_draining:
    description:
    - Settings for connection draining .
    required: false
    type: dict
    suboptions:
      draining_timeout_sec:
        description:
        - Time for which instance will be drained (not accept new connections, but
          still work to finish started).
        required: false
        default: '300'
        type: int
  custom_request_headers:
    description:
    - Headers that the HTTP/S load balancer should add to proxied requests.
    elements: str
    required: false
    type: list
  custom_response_headers:
    description:
    - Headers that the HTTP/S load balancer should add to proxied responses.
    elements: str
    required: false
    type: list
  description:
    description:
    - An optional description of this resource.
    required: false
    type: str
  enable_cdn:
    description:
    - If true, enable Cloud CDN for this BackendService.
    required: false
    type: bool
  health_checks:
    description:
    - The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health
      checking this BackendService. Currently at most one health check can be specified.
    - A health check must be specified unless the backend service uses an internet
      or serverless NEG as a backend.
    - For internal load balancing, a URL to a HealthCheck resource must be specified
      instead.
    elements: str
    required: false
    type: list
  iap:
    description:
    - Settings for enabling Cloud Identity Aware Proxy.
    required: false
    type: dict
    suboptions:
      enabled:
        description:
        - Enables IAP.
        required: false
        type: bool
      oauth2_client_id:
        description:
        - OAuth2 Client ID for IAP .
        required: true
        type: str
      oauth2_client_secret:
        description:
        - OAuth2 Client Secret for IAP .
        required: true
        type: str
  load_balancing_scheme:
    description:
    - Indicates whether the backend service will be used with internal or external
      load balancing. A backend service created for one type of load balancing cannot
      be used with the other.
    - 'Some valid choices include: "EXTERNAL", "INTERNAL_SELF_MANAGED"'
    required: false
    default: EXTERNAL
    type: str
  locality_lb_policy:
    description:
    - The load balancing algorithm used within the scope of the locality.
    - The possible values are - * ROUND_ROBIN - This is a simple policy in which each
      healthy backend is selected in round robin order.
    - "* LEAST_REQUEST - An O(1) algorithm which selects two random healthy hosts
      and picks the host which has fewer active requests."
    - "* RING_HASH - The ring/modulo hash load balancer implements consistent hashing
      to backends. The algorithm has the property that the addition/removal of a host
      from a set of N hosts only affects 1/N of the requests."
    - "* RANDOM - The load balancer selects a random healthy host."
    - "* ORIGINAL_DESTINATION - Backend host is selected based on the client connection
      metadata, i.e., connections are opened to the same address as the destination
      address of the incoming connection before the connection was redirected to the
      load balancer."
    - "* MAGLEV - used as a drop in replacement for the ring hash load balancer."
    - Maglev is not as stable as ring hash but has faster table lookup build times
      and host selection times. For more information about Maglev, refer to https://ai.google/research/pubs/pub44824
      This field is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
    - 'Some valid choices include: "ROUND_ROBIN", "LEAST_REQUEST", "RING_HASH", "RANDOM",
      "ORIGINAL_DESTINATION", "MAGLEV"'
    required: false
    type: str
  name:
    description:
    - Name of the resource. Provided by the client when the resource is created. The
      name must be 1-63 characters long, and comply with RFC1035. Specifically, the
      name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`
      which means the first character must be a lowercase letter, and all following
      characters must be a dash, lowercase letter, or digit, except the last character,
      which cannot be a dash.
    required: true
    type: str
  outlier_detection:
    description:
    - Settings controlling eviction of unhealthy hosts from the load balancing pool.
    - This field is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
    required: false
    type: dict
    suboptions:
      base_ejection_time:
        description:
        - The base time that a host is ejected for. The real time is equal to the
          base time multiplied by the number of times the host has been ejected. Defaults
          to 30000ms or 30s.
        required: false
        type: dict
        suboptions:
          seconds:
            description:
            - Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
              inclusive.
            required: true
            type: int
          nanos:
            description:
            - Span of time that's a fraction of a second at nanosecond resolution.
              Durations less than one second are represented with a 0 `seconds` field
              and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
            required: false
            type: int
      consecutive_errors:
        description:
        - Number of errors before a host is ejected from the connection pool. When
          the backend host is accessed over HTTP, a 5xx return code qualifies as an
          error.
        - Defaults to 5.
        required: false
        default: '5'
        type: int
      consecutive_gateway_failure:
        description:
        - The number of consecutive gateway failures (502, 503, 504 status or connection
          errors that are mapped to one of those status codes) before a consecutive
          gateway failure ejection occurs. Defaults to 5.
        required: false
        default: '5'
        type: int
      enforcing_consecutive_errors:
        description:
        - The percentage chance that a host will be actually ejected when an outlier
          status is detected through consecutive 5xx. This setting can be used to
          disable ejection or to ramp it up slowly. Defaults to 100.
        required: false
        default: '100'
        type: int
      enforcing_consecutive_gateway_failure:
        description:
        - The percentage chance that a host will be actually ejected when an outlier
          status is detected through consecutive gateway failures. This setting can
          be used to disable ejection or to ramp it up slowly. Defaults to 0.
        required: false
        type: int
      enforcing_success_rate:
        description:
        - The percentage chance that a host will be actually ejected when an outlier
          status is detected through success rate statistics. This setting can be
          used to disable ejection or to ramp it up slowly. Defaults to 100.
        required: false
        default: '100'
        type: int
      interval:
        description:
        - Time interval between ejection sweep analysis. This can result in both new
          ejections as well as hosts being returned to service. Defaults to 10 seconds.
        required: false
        type: dict
        suboptions:
          seconds:
            description:
            - Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
              inclusive.
            required: true
            type: int
          nanos:
            description:
            - Span of time that's a fraction of a second at nanosecond resolution.
              Durations less than one second are represented with a 0 `seconds` field
              and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
            required: false
            type: int
      max_ejection_percent:
        description:
        - Maximum percentage of hosts in the load balancing pool for the backend service
          that can be ejected. Defaults to 10%.
        required: false
        default: '10'
        type: int
      success_rate_minimum_hosts:
        description:
        - The number of hosts in a cluster that must have enough request volume to
          detect success rate outliers. If the number of hosts is less than this setting,
          outlier detection via success rate statistics is not performed for any host
          in the cluster. Defaults to 5.
        required: false
        default: '5'
        type: int
      success_rate_request_volume:
        description:
        - The minimum number of total requests that must be collected in one interval
          (as defined by the interval duration above) to include this host in success
          rate based outlier detection. If the volume is lower than this setting,
          outlier detection via success rate statistics is not performed for that
          host. Defaults to 100.
        required: false
        default: '100'
        type: int
      success_rate_stdev_factor:
        description:
        - 'This factor is used to determine the ejection threshold for success rate
          outlier ejection. The ejection threshold is the difference between the mean
          success rate, and the product of this factor and the standard deviation
          of the mean success rate: mean - (stdev * success_rate_stdev_factor). This
          factor is divided by a thousand to get a double. That is, if the desired
          factor is 1.9, the runtime value should be 1900. Defaults to 1900.'
        required: false
        default: '1900'
        type: int
  port_name:
    description:
    - Name of backend port. The same name should appear in the instance groups referenced
      by this service. Required when the load balancing scheme is EXTERNAL.
    required: false
    type: str
  protocol:
    description:
    - The protocol this BackendService uses to communicate with backends.
    - 'The default is HTTP. **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer
      types and may result in errors if used with the GA API.'
    - 'Some valid choices include: "HTTP", "HTTPS", "HTTP2", "TCP", "SSL", "GRPC"'
    required: false
    type: str
  security_policy:
    description:
    - The security policy associated with this backend service.
    required: false
    type: str
  session_affinity:
    description:
    - Type of session affinity to use. The default is NONE. Session affinity is not
      applicable if the protocol is UDP.
    - 'Some valid choices include: "NONE", "CLIENT_IP", "CLIENT_IP_PORT_PROTO", "CLIENT_IP_PROTO",
      "GENERATED_COOKIE", "HEADER_FIELD", "HTTP_COOKIE"'
    required: false
    type: str
  timeout_sec:
    description:
    - How many seconds to wait for the backend before considering it a failed request.
      Default is 30 seconds. Valid range is [1, 86400].
    required: false
    type: int
    aliases:
    - timeout_seconds
  log_config:
    description:
    - This field denotes the logging options for the load balancer traffic served
      by this backend service.
    - If logging is enabled, logs will be exported to Stackdriver.
    required: false
    type: dict
    suboptions:
      enable:
        description:
        - Whether to enable logging for the load balancer traffic served by this backend
          service.
        required: false
        type: bool
      sample_rate:
        description:
        - This field can only be specified if logging is enabled for this backend
          service. The value of the field must be in [0, 1]. This configures the sampling
          rate of requests to the load balancer where 1.0 means all logged requests
          are reported and 0.0 means no logged requests are reported.
        - The default value is 1.0.
        required: false
        type: str
  project:
    description:
    - The Google Cloud Platform project to use.
    type: str
  auth_kind:
    description:
    - The type of credential used.
    type: str
    required: true
    choices:
    - application
    - machineaccount
    - serviceaccount
  service_account_contents:
    description:
    - The contents of a Service Account JSON file, either in a dictionary or as a
      JSON string that represents it.
    type: jsonarg
  service_account_file:
    description:
    - The path of a Service Account JSON file if serviceaccount is selected as type.
    type: path
  service_account_email:
    description:
    - An optional service account email address if machineaccount is selected and
      the user does not wish to use the default email.
    type: str
  scopes:
    description:
    - Array of scopes to be used
    type: list
    elements: str
  env_type:
    description:
    - Specifies which Ansible environment you're running this module within.
    - This should not be set unless you know what you're doing.
    - This only alters the User Agent string for any API requests.
    type: str
notes:
- 'API Reference: U(https://cloud.google.com/compute/docs/reference/v1/backendServices)'
- 'Official Documentation: U(https://cloud.google.com/compute/docs/load-balancing/http/backend-service)'
- for authentication, you can set service_account_file using the C(GCP_SERVICE_ACCOUNT_FILE)
  env variable.
- for authentication, you can set service_account_contents using the C(GCP_SERVICE_ACCOUNT_CONTENTS)
  env variable.
- For authentication, you can set service_account_email using the C(GCP_SERVICE_ACCOUNT_EMAIL)
  env variable.
- For authentication, you can set auth_kind using the C(GCP_AUTH_KIND) env variable.
- For authentication, you can set scopes using the C(GCP_SCOPES) env variable.
- Environment variables values will only be used if the playbook values are not set.
- The I(service_account_email) and I(service_account_file) options are mutually exclusive.
"""

EXAMPLES = """
- name: create a instance group
  google.cloud.gcp_compute_instance_group:
    name: instancegroup-backendservice
    zone: us-central1-a
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"
    state: present
  register: instancegroup

- name: create a HTTP health check
  google.cloud.gcp_compute_http_health_check:
    name: httphealthcheck-backendservice
    healthy_threshold: 10
    port: 8080
    timeout_sec: 2
    unhealthy_threshold: 5
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"
    state: present
  register: healthcheck

- name: create a backend service
  google.cloud.gcp_compute_backend_service:
    name: test_object
    backends:
    - group: "{{ instancegroup.selfLink }}"
    health_checks:
    - "{{ healthcheck.selfLink }}"
    enable_cdn: 'true'
    project: test_project
    auth_kind: serviceaccount
    service_account_file: "/tmp/auth.pem"
    state: present
"""

RETURN = """
affinityCookieTtlSec:
  description:
  - Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set
    to 0, the cookie is non-persistent and lasts only until the end of the browser
    session (or equivalent). The maximum allowed value for TTL is one day.
  - When the load balancing scheme is INTERNAL, this field is not used.
  returned: success
  type: int
backends:
  description:
  - The set of backends that serve this BackendService.
  returned: success
  type: complex
  contains:
    balancingMode:
      description:
      - Specifies the balancing mode for this backend.
      - For global HTTP(S) or TCP/SSL load balancing, the default is UTILIZATION.
        Valid values are UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).
      returned: success
      type: str
    capacityScaler:
      description:
      - A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION,
        RATE or CONNECTION).
      - Default value is 1, which means the group will serve up to 100% of its configured
        capacity (depending on balancingMode). A setting of 0 means the group is completely
        drained, offering 0% of its available Capacity. Valid range is [0.0,1.0].
      returned: success
      type: str
    description:
      description:
      - An optional description of this resource.
      - Provide this property when you create the resource.
      returned: success
      type: str
    group:
      description:
      - The fully-qualified URL of an Instance Group or Network Endpoint Group resource.
        In case of instance group this defines the list of instances that serve traffic.
        Member virtual machine instances from each instance group must live in the
        same zone as the instance group itself. No two backends in a backend service
        are allowed to use same Instance Group resource.
      - For Network Endpoint Groups this defines list of endpoints. All endpoints
        of Network Endpoint Group must be hosted on instances located in the same
        zone as the Network Endpoint Group.
      - Backend services cannot mix Instance Group and Network Endpoint Group backends.
      - Note that you must specify an Instance Group or Network Endpoint Group resource
        using the fully-qualified URL, rather than a partial URL.
      returned: success
      type: str
    maxConnections:
      description:
      - The max number of simultaneous connections for the group. Can be used with
        either CONNECTION or UTILIZATION balancing modes.
      - For CONNECTION mode, either maxConnections or one of maxConnectionsPerInstance
        or maxConnectionsPerEndpoint, as appropriate for group type, must be set.
      returned: success
      type: int
    maxConnectionsPerInstance:
      description:
      - The max number of simultaneous connections that a single backend instance
        can handle. This is used to calculate the capacity of the group. Can be used
        in either CONNECTION or UTILIZATION balancing modes.
      - For CONNECTION mode, either maxConnections or maxConnectionsPerInstance must
        be set.
      returned: success
      type: int
    maxConnectionsPerEndpoint:
      description:
      - The max number of simultaneous connections that a single backend network endpoint
        can handle. This is used to calculate the capacity of the group. Can be used
        in either CONNECTION or UTILIZATION balancing modes.
      - For CONNECTION mode, either maxConnections or maxConnectionsPerEndpoint must
        be set.
      returned: success
      type: int
    maxRate:
      description:
      - The max requests per second (RPS) of the group.
      - Can be used with either RATE or UTILIZATION balancing modes, but required
        if RATE mode. For RATE mode, either maxRate or one of maxRatePerInstance or
        maxRatePerEndpoint, as appropriate for group type, must be set.
      returned: success
      type: int
    maxRatePerInstance:
      description:
      - The max requests per second (RPS) that a single backend instance can handle.
        This is used to calculate the capacity of the group. Can be used in either
        balancing mode. For RATE mode, either maxRate or maxRatePerInstance must be
        set.
      returned: success
      type: str
    maxRatePerEndpoint:
      description:
      - The max requests per second (RPS) that a single backend network endpoint can
        handle. This is used to calculate the capacity of the group. Can be used in
        either balancing mode. For RATE mode, either maxRate or maxRatePerEndpoint
        must be set.
      returned: success
      type: str
    maxUtilization:
      description:
      - Used when balancingMode is UTILIZATION. This ratio defines the CPU utilization
        target for the group. Valid range is [0.0, 1.0].
      returned: success
      type: str
circuitBreakers:
  description:
  - Settings controlling the volume of connections to a backend service. This field
    is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
  returned: success
  type: complex
  contains:
    maxRequestsPerConnection:
      description:
      - Maximum requests for a single backend connection. This parameter is respected
        by both the HTTP/1.1 and HTTP/2 implementations. If not specified, there is
        no limit. Setting this parameter to 1 will effectively disable keep alive.
      returned: success
      type: int
    maxConnections:
      description:
      - The maximum number of connections to the backend cluster.
      - Defaults to 1024.
      returned: success
      type: int
    maxPendingRequests:
      description:
      - The maximum number of pending requests to the backend cluster.
      - Defaults to 1024.
      returned: success
      type: int
    maxRequests:
      description:
      - The maximum number of parallel requests to the backend cluster.
      - Defaults to 1024.
      returned: success
      type: int
    maxRetries:
      description:
      - The maximum number of parallel retries to the backend cluster.
      - Defaults to 3.
      returned: success
      type: int
consistentHash:
  description:
  - Consistent Hash-based load balancing can be used to provide soft session affinity
    based on HTTP headers, cookies or other properties. This load balancing policy
    is applicable only for HTTP connections. The affinity to a particular destination
    host will be lost when one or more hosts are added/removed from the destination
    service. This field specifies parameters that control consistent hashing. This
    field only applies if the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
    This field is only applicable when locality_lb_policy is set to MAGLEV or RING_HASH.
  returned: success
  type: complex
  contains:
    httpCookie:
      description:
      - Hash is based on HTTP Cookie. This field describes a HTTP cookie that will
        be used as the hash key for the consistent hash load balancer. If the cookie
        is not present, it will be generated.
      - This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
      returned: success
      type: complex
      contains:
        ttl:
          description:
          - Lifetime of the cookie.
          returned: success
          type: complex
          contains:
            seconds:
              description:
              - Span of time at a resolution of a second.
              - Must be from 0 to 315,576,000,000 inclusive.
              returned: success
              type: int
            nanos:
              description:
              - Span of time that's a fraction of a second at nanosecond resolution.
                Durations less than one second are represented with a 0 seconds field
                and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
              returned: success
              type: int
        name:
          description:
          - Name of the cookie.
          returned: success
          type: str
        path:
          description:
          - Path to set for the cookie.
          returned: success
          type: str
    httpHeaderName:
      description:
      - The hash based on the value of the specified header field.
      - This field is applicable if the sessionAffinity is set to HEADER_FIELD.
      returned: success
      type: str
    minimumRingSize:
      description:
      - The minimum number of virtual nodes to use for the hash ring.
      - Larger ring sizes result in more granular load distributions. If the number
        of hosts in the load balancing pool is larger than the ring size, each host
        will be assigned a single virtual node.
      - Defaults to 1024.
      returned: success
      type: int
cdnPolicy:
  description:
  - Cloud CDN configuration for this BackendService.
  returned: success
  type: complex
  contains:
    cacheKeyPolicy:
      description:
      - The CacheKeyPolicy for this CdnPolicy.
      returned: success
      type: complex
      contains:
        includeHost:
          description:
          - If true requests to different hosts will be cached separately.
          returned: success
          type: bool
        includeProtocol:
          description:
          - If true, http and https requests will be cached separately.
          returned: success
          type: bool
        includeQueryString:
          description:
          - If true, include query string parameters in the cache key according to
            query_string_whitelist and query_string_blacklist. If neither is set,
            the entire query string will be included.
          - If false, the query string will be excluded from the cache key entirely.
          returned: success
          type: bool
        queryStringBlacklist:
          description:
          - Names of query string parameters to exclude in cache keys.
          - All other parameters will be included. Either specify query_string_whitelist
            or query_string_blacklist, not both.
          - "'&' and '=' will be percent encoded and not treated as delimiters."
          returned: success
          type: list
        queryStringWhitelist:
          description:
          - Names of query string parameters to include in cache keys.
          - All other parameters will be excluded. Either specify query_string_whitelist
            or query_string_blacklist, not both.
          - "'&' and '=' will be percent encoded and not treated as delimiters."
          returned: success
          type: list
    signedUrlCacheMaxAgeSec:
      description:
      - Maximum number of seconds the response to a signed URL request will be considered
        fresh, defaults to 1hr (3600s). After this time period, the response will
        be revalidated before being served.
      - 'When serving responses to signed URL requests, Cloud CDN will internally
        behave as though all responses from this backend had a "Cache-Control: public,
        max-age=[TTL]" header, regardless of any existing Cache-Control header. The
        actual headers served in responses will not be altered.'
      returned: success
      type: int
    defaultTtl:
      description:
      - Specifies the default TTL for cached content served by this origin for responses
        that do not have an existing valid TTL (max-age or s-max-age).
      returned: success
      type: int
    maxTtl:
      description:
      - Specifies the maximum allowed TTL for cached content served by this origin.
      returned: success
      type: int
    clientTtl:
      description:
      - Specifies the maximum allowed TTL for cached content served by this origin.
      returned: success
      type: int
    negativeCaching:
      description:
      - Negative caching allows per-status code TTLs to be set, in order to apply
        fine-grained caching for common errors or redirects.
      returned: success
      type: bool
    negativeCachingPolicy:
      description:
      - Sets a cache TTL for the specified HTTP status code. negativeCaching must
        be enabled to configure negativeCachingPolicy.
      - Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's
        default cache TTLs.
      returned: success
      type: complex
      contains:
        code:
          description:
          - The HTTP status code to define a TTL against. Only HTTP status codes 300,
            301, 308, 404, 405, 410, 421, 451 and 501 can be specified as values,
            and you cannot specify a status code more than once.
          returned: success
          type: int
        ttl:
          description:
          - The TTL (in seconds) for which to cache responses with the corresponding
            status code. The maximum allowed value is 1800s (30 minutes), noting that
            infrequently accessed objects may be evicted from the cache before the
            defined TTL.
          returned: success
          type: int
    cacheMode:
      description:
      - Specifies the cache setting for all responses from this backend.
      - 'The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
        .'
      returned: success
      type: str
    serveWhileStale:
      description:
      - Serve existing content from the cache (if available) when revalidating content
        with the origin, or when an error is encountered when refreshing the cache.
      returned: success
      type: int
connectionDraining:
  description:
  - Settings for connection draining .
  returned: success
  type: complex
  contains:
    drainingTimeoutSec:
      description:
      - Time for which instance will be drained (not accept new connections, but still
        work to finish started).
      returned: success
      type: int
creationTimestamp:
  description:
  - Creation timestamp in RFC3339 text format.
  returned: success
  type: str
customRequestHeaders:
  description:
  - Headers that the HTTP/S load balancer should add to proxied requests.
  returned: success
  type: list
customResponseHeaders:
  description:
  - Headers that the HTTP/S load balancer should add to proxied responses.
  returned: success
  type: list
fingerprint:
  description:
  - Fingerprint of this resource. A hash of the contents stored in this object. This
    field is used in optimistic locking.
  returned: success
  type: str
description:
  description:
  - An optional description of this resource.
  returned: success
  type: str
enableCDN:
  description:
  - If true, enable Cloud CDN for this BackendService.
  returned: success
  type: bool
healthChecks:
  description:
  - The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health
    checking this BackendService. Currently at most one health check can be specified.
  - A health check must be specified unless the backend service uses an internet or
    serverless NEG as a backend.
  - For internal load balancing, a URL to a HealthCheck resource must be specified
    instead.
  returned: success
  type: list
id:
  description:
  - The unique identifier for the resource.
  returned: success
  type: int
iap:
  description:
  - Settings for enabling Cloud Identity Aware Proxy.
  returned: success
  type: complex
  contains:
    enabled:
      description:
      - Enables IAP.
      returned: success
      type: bool
    oauth2ClientId:
      description:
      - OAuth2 Client ID for IAP .
      returned: success
      type: str
    oauth2ClientSecret:
      description:
      - OAuth2 Client Secret for IAP .
      returned: success
      type: str
    oauth2ClientSecretSha256:
      description:
      - OAuth2 Client Secret SHA-256 for IAP .
      returned: success
      type: str
loadBalancingScheme:
  description:
  - Indicates whether the backend service will be used with internal or external load
    balancing. A backend service created for one type of load balancing cannot be
    used with the other.
  returned: success
  type: str
localityLbPolicy:
  description:
  - The load balancing algorithm used within the scope of the locality.
  - The possible values are - * ROUND_ROBIN - This is a simple policy in which each
    healthy backend is selected in round robin order.
  - "* LEAST_REQUEST - An O(1) algorithm which selects two random healthy hosts and
    picks the host which has fewer active requests."
  - "* RING_HASH - The ring/modulo hash load balancer implements consistent hashing
    to backends. The algorithm has the property that the addition/removal of a host
    from a set of N hosts only affects 1/N of the requests."
  - "* RANDOM - The load balancer selects a random healthy host."
  - "* ORIGINAL_DESTINATION - Backend host is selected based on the client connection
    metadata, i.e., connections are opened to the same address as the destination
    address of the incoming connection before the connection was redirected to the
    load balancer."
  - "* MAGLEV - used as a drop in replacement for the ring hash load balancer."
  - Maglev is not as stable as ring hash but has faster table lookup build times and
    host selection times. For more information about Maglev, refer to https://ai.google/research/pubs/pub44824
    This field is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
  returned: success
  type: str
name:
  description:
  - Name of the resource. Provided by the client when the resource is created. The
    name must be 1-63 characters long, and comply with RFC1035. Specifically, the
    name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`
    which means the first character must be a lowercase letter, and all following
    characters must be a dash, lowercase letter, or digit, except the last character,
    which cannot be a dash.
  returned: success
  type: str
outlierDetection:
  description:
  - Settings controlling eviction of unhealthy hosts from the load balancing pool.
  - This field is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
  returned: success
  type: complex
  contains:
    baseEjectionTime:
      description:
      - The base time that a host is ejected for. The real time is equal to the base
        time multiplied by the number of times the host has been ejected. Defaults
        to 30000ms or 30s.
      returned: success
      type: complex
      contains:
        seconds:
          description:
          - Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
            inclusive.
          returned: success
          type: int
        nanos:
          description:
          - Span of time that's a fraction of a second at nanosecond resolution. Durations
            less than one second are represented with a 0 `seconds` field and a positive
            `nanos` field. Must be from 0 to 999,999,999 inclusive.
          returned: success
          type: int
    consecutiveErrors:
      description:
      - Number of errors before a host is ejected from the connection pool. When the
        backend host is accessed over HTTP, a 5xx return code qualifies as an error.
      - Defaults to 5.
      returned: success
      type: int
    consecutiveGatewayFailure:
      description:
      - The number of consecutive gateway failures (502, 503, 504 status or connection
        errors that are mapped to one of those status codes) before a consecutive
        gateway failure ejection occurs. Defaults to 5.
      returned: success
      type: int
    enforcingConsecutiveErrors:
      description:
      - The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive 5xx. This setting can be used to disable
        ejection or to ramp it up slowly. Defaults to 100.
      returned: success
      type: int
    enforcingConsecutiveGatewayFailure:
      description:
      - The percentage chance that a host will be actually ejected when an outlier
        status is detected through consecutive gateway failures. This setting can
        be used to disable ejection or to ramp it up slowly. Defaults to 0.
      returned: success
      type: int
    enforcingSuccessRate:
      description:
      - The percentage chance that a host will be actually ejected when an outlier
        status is detected through success rate statistics. This setting can be used
        to disable ejection or to ramp it up slowly. Defaults to 100.
      returned: success
      type: int
    interval:
      description:
      - Time interval between ejection sweep analysis. This can result in both new
        ejections as well as hosts being returned to service. Defaults to 10 seconds.
      returned: success
      type: complex
      contains:
        seconds:
          description:
          - Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
            inclusive.
          returned: success
          type: int
        nanos:
          description:
          - Span of time that's a fraction of a second at nanosecond resolution. Durations
            less than one second are represented with a 0 `seconds` field and a positive
            `nanos` field. Must be from 0 to 999,999,999 inclusive.
          returned: success
          type: int
    maxEjectionPercent:
      description:
      - Maximum percentage of hosts in the load balancing pool for the backend service
        that can be ejected. Defaults to 10%.
      returned: success
      type: int
    successRateMinimumHosts:
      description:
      - The number of hosts in a cluster that must have enough request volume to detect
        success rate outliers. If the number of hosts is less than this setting, outlier
        detection via success rate statistics is not performed for any host in the
        cluster. Defaults to 5.
      returned: success
      type: int
    successRateRequestVolume:
      description:
      - The minimum number of total requests that must be collected in one interval
        (as defined by the interval duration above) to include this host in success
        rate based outlier detection. If the volume is lower than this setting, outlier
        detection via success rate statistics is not performed for that host. Defaults
        to 100.
      returned: success
      type: int
    successRateStdevFactor:
      description:
      - 'This factor is used to determine the ejection threshold for success rate
        outlier ejection. The ejection threshold is the difference between the mean
        success rate, and the product of this factor and the standard deviation of
        the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor
        is divided by a thousand to get a double. That is, if the desired factor is
        1.9, the runtime value should be 1900. Defaults to 1900.'
      returned: success
      type: int
portName:
  description:
  - Name of backend port. The same name should appear in the instance groups referenced
    by this service. Required when the load balancing scheme is EXTERNAL.
  returned: success
  type: str
protocol:
  description:
  - The protocol this BackendService uses to communicate with backends.
  - 'The default is HTTP. **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer
    types and may result in errors if used with the GA API.'
  returned: success
  type: str
securityPolicy:
  description:
  - The security policy associated with this backend service.
  returned: success
  type: str
sessionAffinity:
  description:
  - Type of session affinity to use. The default is NONE. Session affinity is not
    applicable if the protocol is UDP.
  returned: success
  type: str
timeoutSec:
  description:
  - How many seconds to wait for the backend before considering it a failed request.
    Default is 30 seconds. Valid range is [1, 86400].
  returned: success
  type: int
logConfig:
  description:
  - This field denotes the logging options for the load balancer traffic served by
    this backend service.
  - If logging is enabled, logs will be exported to Stackdriver.
  returned: success
  type: complex
  contains:
    enable:
      description:
      - Whether to enable logging for the load balancer traffic served by this backend
        service.
      returned: success
      type: bool
    sampleRate:
      description:
      - This field can only be specified if logging is enabled for this backend service.
        The value of the field must be in [0, 1]. This configures the sampling rate
        of requests to the load balancer where 1.0 means all logged requests are reported
        and 0.0 means no logged requests are reported.
      - The default value is 1.0.
      returned: success
      type: str
"""

################################################################################
# Imports
################################################################################

from ansible_collections.google.cloud.plugins.module_utils.gcp_utils import (
    navigate_hash,
    GcpSession,
    GcpModule,
    GcpRequest,
    remove_nones_from_dict,
    replace_resource_dict,
)
import json
import time

################################################################################
# Main
################################################################################


def main():
    """Main function"""

    module = GcpModule(
        argument_spec=dict(
            state=dict(default="present", choices=["present", "absent"], type="str"),
            affinity_cookie_ttl_sec=dict(type="int"),
            fingerprint=dict(type="str"),
            backends=dict(
                type="list",
                elements="dict",
                options=dict(
                    balancing_mode=dict(default="UTILIZATION", type="str"),
                    # TODO: capacity_scaler does some value normalization
                    # server-side, so there needs to be a way to do proper
                    # value comparison.
                    capacity_scaler=dict(default="1", type="str"),
                    description=dict(type="str"),
                    group=dict(required=True, type="str"),
                    max_connections=dict(type="int"),
                    max_connections_per_instance=dict(type="int"),
                    max_connections_per_endpoint=dict(type="int"),
                    max_rate=dict(type="int"),
                    max_rate_per_instance=dict(type="str"),
                    max_rate_per_endpoint=dict(type="str"),
                    max_utilization=dict(type="str"),
                ),
            ),
            circuit_breakers=dict(
                type="dict",
                options=dict(
                    max_requests_per_connection=dict(type="int"),
                    max_connections=dict(default=1024, type="int"),
                    max_pending_requests=dict(default=1024, type="int"),
                    max_requests=dict(default=1024, type="int"),
                    max_retries=dict(default=3, type="int"),
                ),
            ),
            consistent_hash=dict(
                type="dict",
                options=dict(
                    http_cookie=dict(
                        type="dict",
                        options=dict(
                            ttl=dict(
                                type="dict",
                                options=dict(
                                    seconds=dict(required=True, type="int"),
                                    nanos=dict(type="int"),
                                ),
                            ),
                            name=dict(type="str"),
                            path=dict(type="str"),
                        ),
                    ),
                    http_header_name=dict(type="str"),
                    minimum_ring_size=dict(default=1024, type="int"),
                ),
            ),
            cdn_policy=dict(
                type="dict",
                options=dict(
                    cache_key_policy=dict(
                        type="dict",
                        options=dict(
                            include_host=dict(type="bool"),
                            include_protocol=dict(type="bool"),
                            include_query_string=dict(type="bool"),
                            query_string_blacklist=dict(type="list", elements="str"),
                            query_string_whitelist=dict(type="list", elements="str"),
                        ),
                    ),
                    signed_url_cache_max_age_sec=dict(default=3600, type="int"),
                    default_ttl=dict(type="int"),
                    max_ttl=dict(type="int"),
                    client_ttl=dict(type="int"),
                    negative_caching=dict(type="bool"),
                    negative_caching_policy=dict(
                        type="list",
                        elements="dict",
                        options=dict(code=dict(type="int"), ttl=dict(type="int")),
                    ),
                    cache_mode=dict(type="str"),
                    serve_while_stale=dict(type="int"),
                ),
            ),
            connection_draining=dict(
                type="dict",
                options=dict(draining_timeout_sec=dict(default=300, type="int")),
            ),
            custom_request_headers=dict(type="list", elements="str"),
            custom_response_headers=dict(type="list", elements="str"),
            description=dict(type="str"),
            enable_cdn=dict(type="bool"),
            health_checks=dict(type="list", elements="str"),
            iap=dict(
                type="dict",
                options=dict(
                    enabled=dict(type="bool"),
                    oauth2_client_id=dict(required=True, type="str"),
                    oauth2_client_secret=dict(required=True, type="str", no_log=True),
                ),
            ),
            load_balancing_scheme=dict(default="EXTERNAL", type="str"),
            locality_lb_policy=dict(type="str"),
            name=dict(required=True, type="str"),
            outlier_detection=dict(
                type="dict",
                options=dict(
                    base_ejection_time=dict(
                        type="dict",
                        options=dict(
                            seconds=dict(required=True, type="int"),
                            nanos=dict(type="int"),
                        ),
                    ),
                    consecutive_errors=dict(default=5, type="int"),
                    consecutive_gateway_failure=dict(default=5, type="int"),
                    enforcing_consecutive_errors=dict(default=100, type="int"),
                    enforcing_consecutive_gateway_failure=dict(default=0, type="int"),
                    enforcing_success_rate=dict(default=100, type="int"),
                    interval=dict(
                        type="dict",
                        options=dict(
                            seconds=dict(required=True, type="int"),
                            nanos=dict(type="int"),
                        ),
                    ),
                    max_ejection_percent=dict(default=10, type="int"),
                    success_rate_minimum_hosts=dict(default=5, type="int"),
                    success_rate_request_volume=dict(default=100, type="int"),
                    success_rate_stdev_factor=dict(default=1900, type="int"),
                ),
            ),
            port_name=dict(type="str"),
            protocol=dict(type="str"),
            security_policy=dict(type="str"),
            session_affinity=dict(type="str"),
            timeout_sec=dict(type="int", aliases=["timeout_seconds"]),
            log_config=dict(
                type="dict",
                options=dict(enable=dict(type="bool"), sample_rate=dict(type="str")),
            ),
        )
    )

    if not module.params["scopes"]:
        module.params["scopes"] = ["https://www.googleapis.com/auth/compute"]

    state = module.params["state"]
    kind = "compute#backendService"

    fetch = fetch_resource(module, self_link(module), kind)
    changed = False

    if fetch:
        module.params["fingerprint"] = fetch["fingerprint"]
        if state == "present":
            if is_different(module, fetch):
                update(module, self_link(module), kind)
                fetch = fetch_resource(module, self_link(module), kind)
                changed = True
        else:
            delete(module, self_link(module), kind)
            fetch = {}
            changed = True
    else:
        if state == "present":
            fetch = create(module, collection(module), kind)
            changed = True
        else:
            fetch = {}

    fetch.update({"changed": changed})

    module.exit_json(**fetch)


def create(module, link, kind):
    auth = GcpSession(module, "compute")
    return wait_for_operation(module, auth.post(link, resource_to_request(module)))


def update(module, link, kind):
    auth = GcpSession(module, "compute")
    return wait_for_operation(module, auth.put(link, resource_to_request(module)))


def delete(module, link, kind):
    auth = GcpSession(module, "compute")
    return wait_for_operation(module, auth.delete(link))


def resource_to_request(module):
    request = {
        "kind": "compute#backendService",
        "affinityCookieTtlSec": module.params.get("affinity_cookie_ttl_sec"),
        "backends": BackendServiceBackendsArray(
            module.params.get("backends", []), module
        ).to_request(),
        "circuitBreakers": BackendServiceCircuitbreakers(
            module.params.get("circuit_breakers", {}), module
        ).to_request(),
        "consistentHash": BackendServiceConsistenthash(
            module.params.get("consistent_hash", {}), module
        ).to_request(),
        "cdnPolicy": BackendServiceCdnpolicy(
            module.params.get("cdn_policy", {}), module
        ).to_request(),
        "connectionDraining": BackendServiceConnectiondraining(
            module.params.get("connection_draining", {}), module
        ).to_request(),
        "customRequestHeaders": module.params.get("custom_request_headers"),
        "customResponseHeaders": module.params.get("custom_response_headers"),
        "description": module.params.get("description"),
        "enableCDN": module.params.get("enable_cdn"),
        "healthChecks": module.params.get("health_checks"),
        "iap": BackendServiceIap(module.params.get("iap", {}), module).to_request(),
        "loadBalancingScheme": module.params.get("load_balancing_scheme"),
        "localityLbPolicy": module.params.get("locality_lb_policy"),
        "name": module.params.get("name"),
        "outlierDetection": BackendServiceOutlierdetection(
            module.params.get("outlier_detection", {}), module
        ).to_request(),
        "portName": module.params.get("port_name"),
        "protocol": module.params.get("protocol"),
        "securityPolicy": module.params.get("security_policy"),
        "sessionAffinity": module.params.get("session_affinity"),
        "timeoutSec": module.params.get("timeout_sec"),
        "logConfig": BackendServiceLogconfig(
            module.params.get("log_config", {}), module
        ).to_request(),
        "fingerprint": module.params.get("fingerprint"),
    }
    return_vals = {}
    for k, v in request.items():
        if v or v is False:
            return_vals[k] = v

    return return_vals


def fetch_resource(module, link, kind, allow_not_found=True):
    auth = GcpSession(module, "compute")
    return return_if_object(module, auth.get(link), kind, allow_not_found)


def self_link(module):
    return "https://compute.googleapis.com/compute/v1/projects/{project}/global/backendServices/{name}".format(
        **module.params
    )


def collection(module):
    return "https://compute.googleapis.com/compute/v1/projects/{project}/global/backendServices".format(
        **module.params
    )


def return_if_object(module, response, kind, allow_not_found=False):
    # If not found, return nothing.
    if allow_not_found and response.status_code == 404:
        return None

    # If no content, return nothing.
    if response.status_code == 204:
        return None

    try:
        module.raise_for_status(response)
        result = response.json()
    except getattr(json.decoder, "JSONDecodeError", ValueError):
        module.fail_json(msg="Invalid JSON response with error: %s" % response.text)

    if navigate_hash(result, ["error", "errors"]):
        module.fail_json(msg=navigate_hash(result, ["error", "errors"]))

    return result


def is_different(module, response):
    request = resource_to_request(module)
    response = response_to_hash(module, response)

    # Remove all output-only from response.
    response_vals = {}
    for k, v in response.items():
        if k in request:
            response_vals[k] = v

    request_vals = {}
    for k, v in request.items():
        if k in response:
            request_vals[k] = v

    # req = GcpRequest(request_vals)
    # res = GcpRequest(response_vals)
    # import epdb; epdb.serve()
    return GcpRequest(request_vals) != GcpRequest(response_vals)


# Remove unnecessary properties from the response.
# This is for doing comparisons with Ansible's current parameters.
def response_to_hash(module, response):
    return {
        "affinityCookieTtlSec": response.get("affinityCookieTtlSec"),
        "backends": BackendServiceBackendsArray(
            response.get("backends", []), module
        ).from_response(),
        "circuitBreakers": BackendServiceCircuitbreakers(
            response.get("circuitBreakers", {}), module
        ).from_response(),
        "consistentHash": BackendServiceConsistenthash(
            response.get("consistentHash", {}), module
        ).from_response(),
        "cdnPolicy": BackendServiceCdnpolicy(
            response.get("cdnPolicy", {}), module
        ).from_response(),
        "connectionDraining": BackendServiceConnectiondraining(
            response.get("connectionDraining", {}), module
        ).from_response(),
        "creationTimestamp": response.get("creationTimestamp"),
        "customRequestHeaders": response.get("customRequestHeaders"),
        "customResponseHeaders": response.get("customResponseHeaders"),
        "fingerprint": response.get("fingerprint"),
        "description": response.get("description"),
        "enableCDN": response.get("enableCDN"),
        "healthChecks": response.get("healthChecks"),
        "id": response.get("id"),
        "iap": BackendServiceIap(response.get("iap", {}), module).from_response(),
        "loadBalancingScheme": module.params.get("load_balancing_scheme"),
        "localityLbPolicy": response.get("localityLbPolicy"),
        "name": module.params.get("name"),
        "outlierDetection": BackendServiceOutlierdetection(
            response.get("outlierDetection", {}), module
        ).from_response(),
        "portName": response.get("portName"),
        "protocol": response.get("protocol"),
        "securityPolicy": response.get("securityPolicy"),
        "sessionAffinity": response.get("sessionAffinity"),
        "timeoutSec": response.get("timeoutSec"),
        "logConfig": BackendServiceLogconfig(
            response.get("logConfig", {}), module
        ).from_response(),
    }


def async_op_url(module, extra_data=None):
    if extra_data is None:
        extra_data = {}
    url = "https://compute.googleapis.com/compute/v1/projects/{project}/global/operations/{op_id}"
    combined = extra_data.copy()
    combined.update(module.params)
    return url.format(**combined)


def wait_for_operation(module, response):
    op_result = return_if_object(module, response, "compute#operation")
    if op_result is None:
        return {}
    status = navigate_hash(op_result, ["status"])
    wait_done = wait_for_completion(status, op_result, module)
    return fetch_resource(
        module, navigate_hash(wait_done, ["targetLink"]), "compute#backendService"
    )


def wait_for_completion(status, op_result, module):
    op_id = navigate_hash(op_result, ["name"])
    op_uri = async_op_url(module, {"op_id": op_id})
    while status != "DONE":
        raise_if_errors(op_result, ["error", "errors"], module)
        time.sleep(1.0)
        op_result = fetch_resource(module, op_uri, "compute#operation", False)
        status = navigate_hash(op_result, ["status"])
    return op_result


def raise_if_errors(response, err_path, module):
    errors = navigate_hash(response, err_path)
    if errors is not None:
        module.fail_json(msg=errors)


class BackendServiceBackendsArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return remove_nones_from_dict(
            {
                "balancingMode": item.get("balancing_mode"),
                "capacityScaler": item.get("capacity_scaler"),
                "description": item.get("description"),
                "group": item.get("group"),
                "maxConnections": item.get("max_connections"),
                "maxConnectionsPerInstance": item.get("max_connections_per_instance"),
                "maxConnectionsPerEndpoint": item.get("max_connections_per_endpoint"),
                "maxRate": item.get("max_rate"),
                "maxRatePerInstance": item.get("max_rate_per_instance"),
                "maxRatePerEndpoint": item.get("max_rate_per_endpoint"),
                "maxUtilization": item.get("max_utilization"),
            }
        )

    def _response_from_item(self, item):
        return remove_nones_from_dict(
            {
                "balancingMode": item.get("balancingMode"),
                "capacityScaler": item.get("capacityScaler"),
                "description": item.get("description"),
                "group": item.get("group"),
                "maxConnections": item.get("maxConnections"),
                "maxConnectionsPerInstance": item.get("maxConnectionsPerInstance"),
                "maxConnectionsPerEndpoint": item.get("maxConnectionsPerEndpoint"),
                "maxRate": item.get("maxRate"),
                "maxRatePerInstance": item.get("maxRatePerInstance"),
                "maxRatePerEndpoint": item.get("maxRatePerEndpoint"),
                "maxUtilization": item.get("maxUtilization"),
            }
        )


class BackendServiceCircuitbreakers(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "maxRequestsPerConnection": self.request.get(
                    "max_requests_per_connection"
                ),
                "maxConnections": self.request.get("max_connections"),
                "maxPendingRequests": self.request.get("max_pending_requests"),
                "maxRequests": self.request.get("max_requests"),
                "maxRetries": self.request.get("max_retries"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "maxRequestsPerConnection": self.request.get(
                    "maxRequestsPerConnection"
                ),
                "maxConnections": self.request.get("maxConnections"),
                "maxPendingRequests": self.request.get("maxPendingRequests"),
                "maxRequests": self.request.get("maxRequests"),
                "maxRetries": self.request.get("maxRetries"),
            }
        )


class BackendServiceConsistenthash(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "httpCookie": BackendServiceHttpcookie(
                    self.request.get("http_cookie", {}), self.module
                ).to_request(),
                "httpHeaderName": self.request.get("http_header_name"),
                "minimumRingSize": self.request.get("minimum_ring_size"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "httpCookie": BackendServiceHttpcookie(
                    self.request.get("httpCookie", {}), self.module
                ).from_response(),
                "httpHeaderName": self.request.get("httpHeaderName"),
                "minimumRingSize": self.request.get("minimumRingSize"),
            }
        )


class BackendServiceHttpcookie(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "ttl": BackendServiceTtl(
                    self.request.get("ttl", {}), self.module
                ).to_request(),
                "name": self.request.get("name"),
                "path": self.request.get("path"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "ttl": BackendServiceTtl(
                    self.request.get("ttl", {}), self.module
                ).from_response(),
                "name": self.request.get("name"),
                "path": self.request.get("path"),
            }
        )


class BackendServiceTtl(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {"seconds": self.request.get("seconds"), "nanos": self.request.get("nanos")}
        )

    def from_response(self):
        return remove_nones_from_dict(
            {"seconds": self.request.get("seconds"), "nanos": self.request.get("nanos")}
        )


class BackendServiceCdnpolicy(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "cacheKeyPolicy": BackendServiceCachekeypolicy(
                    self.request.get("cache_key_policy", {}), self.module
                ).to_request(),
                "signedUrlCacheMaxAgeSec": self.request.get(
                    "signed_url_cache_max_age_sec"
                ),
                "defaultTtl": self.request.get("default_ttl"),
                "maxTtl": self.request.get("max_ttl"),
                "clientTtl": self.request.get("client_ttl"),
                "negativeCaching": self.request.get("negative_caching"),
                "negativeCachingPolicy": BackendServiceNegativecachingpolicyArray(
                    self.request.get("negative_caching_policy", []), self.module
                ).to_request(),
                "cacheMode": self.request.get("cache_mode"),
                "serveWhileStale": self.request.get("serve_while_stale"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "cacheKeyPolicy": BackendServiceCachekeypolicy(
                    self.request.get("cacheKeyPolicy", {}), self.module
                ).from_response(),
                "signedUrlCacheMaxAgeSec": self.request.get("signedUrlCacheMaxAgeSec"),
                "defaultTtl": self.request.get("defaultTtl"),
                "maxTtl": self.request.get("maxTtl"),
                "clientTtl": self.request.get("clientTtl"),
                "negativeCaching": self.request.get("negativeCaching"),
                "negativeCachingPolicy": BackendServiceNegativecachingpolicyArray(
                    self.request.get("negativeCachingPolicy", []), self.module
                ).from_response(),
                "cacheMode": self.request.get("cacheMode"),
                "serveWhileStale": self.request.get("serveWhileStale"),
            }
        )


class BackendServiceCachekeypolicy(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "includeHost": self.request.get("include_host"),
                "includeProtocol": self.request.get("include_protocol"),
                "includeQueryString": self.request.get("include_query_string"),
                "queryStringBlacklist": self.request.get("query_string_blacklist"),
                "queryStringWhitelist": self.request.get("query_string_whitelist"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "includeHost": self.request.get("includeHost"),
                "includeProtocol": self.request.get("includeProtocol"),
                "includeQueryString": self.request.get("includeQueryString"),
                "queryStringBlacklist": self.request.get("queryStringBlacklist"),
                "queryStringWhitelist": self.request.get("queryStringWhitelist"),
            }
        )


class BackendServiceNegativecachingpolicyArray(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = []

    def to_request(self):
        items = []
        for item in self.request:
            items.append(self._request_for_item(item))
        return items

    def from_response(self):
        items = []
        for item in self.request:
            items.append(self._response_from_item(item))
        return items

    def _request_for_item(self, item):
        return remove_nones_from_dict(
            {"code": item.get("code"), "ttl": item.get("ttl")}
        )

    def _response_from_item(self, item):
        return remove_nones_from_dict(
            {"code": item.get("code"), "ttl": item.get("ttl")}
        )


class BackendServiceConnectiondraining(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {"drainingTimeoutSec": self.request.get("draining_timeout_sec")}
        )

    def from_response(self):
        return remove_nones_from_dict(
            {"drainingTimeoutSec": self.request.get("drainingTimeoutSec")}
        )


class BackendServiceIap(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "enabled": self.request.get("enabled"),
                "oauth2ClientId": self.request.get("oauth2_client_id"),
                "oauth2ClientSecret": self.request.get("oauth2_client_secret"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "enabled": self.request.get("enabled"),
                "oauth2ClientId": self.request.get("oauth2ClientId"),
                "oauth2ClientSecret": self.request.get("oauth2ClientSecret"),
            }
        )


class BackendServiceOutlierdetection(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "baseEjectionTime": BackendServiceBaseejectiontime(
                    self.request.get("base_ejection_time", {}), self.module
                ).to_request(),
                "consecutiveErrors": self.request.get("consecutive_errors"),
                "consecutiveGatewayFailure": self.request.get(
                    "consecutive_gateway_failure"
                ),
                "enforcingConsecutiveErrors": self.request.get(
                    "enforcing_consecutive_errors"
                ),
                "enforcingConsecutiveGatewayFailure": self.request.get(
                    "enforcing_consecutive_gateway_failure"
                ),
                "enforcingSuccessRate": self.request.get("enforcing_success_rate"),
                "interval": BackendServiceInterval(
                    self.request.get("interval", {}), self.module
                ).to_request(),
                "maxEjectionPercent": self.request.get("max_ejection_percent"),
                "successRateMinimumHosts": self.request.get(
                    "success_rate_minimum_hosts"
                ),
                "successRateRequestVolume": self.request.get(
                    "success_rate_request_volume"
                ),
                "successRateStdevFactor": self.request.get("success_rate_stdev_factor"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "baseEjectionTime": BackendServiceBaseejectiontime(
                    self.request.get("baseEjectionTime", {}), self.module
                ).from_response(),
                "consecutiveErrors": self.request.get("consecutiveErrors"),
                "consecutiveGatewayFailure": self.request.get(
                    "consecutiveGatewayFailure"
                ),
                "enforcingConsecutiveErrors": self.request.get(
                    "enforcingConsecutiveErrors"
                ),
                "enforcingConsecutiveGatewayFailure": self.request.get(
                    "enforcingConsecutiveGatewayFailure"
                ),
                "enforcingSuccessRate": self.request.get("enforcingSuccessRate"),
                "interval": BackendServiceInterval(
                    self.request.get("interval", {}), self.module
                ).from_response(),
                "maxEjectionPercent": self.request.get("maxEjectionPercent"),
                "successRateMinimumHosts": self.request.get("successRateMinimumHosts"),
                "successRateRequestVolume": self.request.get(
                    "successRateRequestVolume"
                ),
                "successRateStdevFactor": self.request.get("successRateStdevFactor"),
            }
        )


class BackendServiceBaseejectiontime(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {"seconds": self.request.get("seconds"), "nanos": self.request.get("nanos")}
        )

    def from_response(self):
        return remove_nones_from_dict(
            {"seconds": self.request.get("seconds"), "nanos": self.request.get("nanos")}
        )


class BackendServiceInterval(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {"seconds": self.request.get("seconds"), "nanos": self.request.get("nanos")}
        )

    def from_response(self):
        return remove_nones_from_dict(
            {"seconds": self.request.get("seconds"), "nanos": self.request.get("nanos")}
        )


class BackendServiceLogconfig(object):
    def __init__(self, request, module):
        self.module = module
        if request:
            self.request = request
        else:
            self.request = {}

    def to_request(self):
        return remove_nones_from_dict(
            {
                "enable": self.request.get("enable"),
                "sampleRate": self.request.get("sample_rate"),
            }
        )

    def from_response(self):
        return remove_nones_from_dict(
            {
                "enable": self.request.get("enable"),
                "sampleRate": self.request.get("sampleRate"),
            }
        )


if __name__ == "__main__":
    main()
