#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2017-2026 Google
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
# ----------------------------------------------------------------------------
#

from __future__ import absolute_import, division, print_function

__metaclass__ = type

################################################################################
# Documentation
################################################################################

ANSIBLE_METADATA = {
    "metadata_version": "1.1",
    "status": ["preview"],
    "supported_by": "community",
}

DOCUMENTATION = r"""
---
author:
  - Google Inc. (@googlecloudplatform)
description:
  - ReasoningEngine provides a customizable runtime for models to determine which actions to take and in which order.
extends_documentation_fragment:
  - google.cloud.gcp
module: gcp_vertexai_reasoning_engine
notes:
  - 'API Reference: U(https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.reasoningEngines/)'
  - 'Develop and deploy agents on Vertex AI Agent Engine Guide: U(https://cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/quickstart)'
options:
  description:
    description:
      - The description of the ReasoningEngine.
    type: str
  display_name:
    description:
      - The display name of the ReasoningEngine.
    required: true
    type: str
  encryption_spec:
    description:
      - Customer-managed encryption key spec for a ReasoningEngine.
      - If set, this ReasoningEngine and all sub-resources of this ReasoningEngine will be secured by this key.
    suboptions:
      kms_key_name:
        description:
          - The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource.
          - 'Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key.'
          - The key needs to be in the same region as where the compute resource is created.
        required: true
        type: str
    type: dict
  region:
    description:
      - The region of the reasoning engine.
      - eg us-central1.
    type: str
  spec:
    description:
      - Configurations of the ReasoningEngine.
    suboptions:
      agent_framework:
        description:
          - The OSS agent framework used to develop the agent.
        type: str
      class_methods:
        description:
          - Declarations for object class methods in OpenAPI specification format.
        type: str
      deployment_spec:
        description:
          - The specification of a Reasoning Engine deployment.
        suboptions:
          container_concurrency:
            description:
              - Concurrency for each container and agent server.
              - 'Recommended value: 2 * cpu + 1.'
              - Defaults to 9.
            type: int
          env:
            description:
              - Environment variables to be set with the Reasoning Engine deployment.
            elements: dict
            suboptions:
              name:
                description:
                  - The name of the environment variable.
                  - Must be a valid C identifier.
                required: true
                type: str
              value:
                description:
                  - >-
                    Variables that reference a $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service

                    environment variables.
                  - If a variable cannot be resolved, the reference in the input string will be unchanged.
                  - 'The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).'
                  - Escaped references will never be expanded, regardless of whether the variable exists or not.
                required: true
                type: str
            type: list
          max_instances:
            description:
              - The maximum number of application instances that can be launched to handle increased traffic.
              - Defaults to 100.
              - 'Range: [1, 1000].'
              - If VPC-SC or PSC-I is enabled, the acceptable range is [1, 100].
            type: int
          min_instances:
            description:
              - The minimum number of application instances that will be kept running at all times.
              - Defaults to 1.
              - 'Range: [0, 10].'
            type: int
          psc_interface_config:
            description:
              - Configuration for PSC-Interface.
            suboptions:
              dns_peering_configs:
                description:
                  - DNS peering configurations.
                  - >-
                    When specified, Vertex AI will attempt to configure DNS peering zones in the tenant project VPC to resolve the specified domains using the

                    target network's Cloud DNS.
                  - The user must grant the dns.peer role to the Vertex AI service Agent on the target project.
                elements: dict
                suboptions:
                  domain:
                    description:
                      - The DNS name suffix of the zone being peered to, e.g., "my-internal-domain.corp.".
                      - Must end with a dot.
                    required: true
                    type: str
                  target_network:
                    description:
                      - The VPC network name in the targetProject where the DNS zone specified by 'domain' is visible.
                    required: true
                    type: str
                  target_project:
                    description:
                      - The project id hosting the Cloud DNS managed zone that contains the 'domain'.
                      - The Vertex AI service Agent requires the dns.peer role on this project.
                    required: true
                    type: str
                type: list
              network_attachment:
                description:
                  - The name of the Compute Engine network attachment to attach to the resource within the region and user project.
                  - To specify this field, you must have already created a network attachment.
                  - This field is only used for resources using PSC-Interface.
                type: str
            type: dict
          resource_limits:
            description:
              - Resource limits for each container.
              - Only 'cpu' and 'memory' keys are supported.
              - 'Defaults to {"cpu": "4", "memory": "4Gi"}.'
              - The only supported values for CPU are '1', '2', '4', '6' and '8'.
              - For more information, go to https://cloud.google.com/run/docs/configuring/cpu.
              - The only supported values for memory are '1Gi', '2Gi', ..
              - '''32 Gi''.'
              - For more information, go to https://cloud.google.com/run/docs/configuring/memory-limits.
            type: dict
          secret_env:
            description:
              - Environment variables where the value is a secret in Cloud Secret Manager.
              - >-
                To use this feature, add 'Secret Manager Secret Accessor' role (roles/secretmanager.secretAccessor) to AI Platform Reasoning Engine service

                Agent.
            elements: dict
            suboptions:
              name:
                description:
                  - The name of the environment variable.
                  - Must be a valid C identifier.
                required: true
                type: str
              secret_ref:
                description:
                  - Reference to a secret stored in the Cloud Secret Manager that will provide the value for this environment variable.
                required: true
                suboptions:
                  secret:
                    description:
                      - The name of the secret in Cloud Secret Manager.
                      - 'Format: {secret_name}.'
                    required: true
                    type: str
                  version:
                    description:
                      - The Cloud Secret Manager secret version.
                      - Can be 'latest' for the latest version, an integer for a specific version, or a version alias.
                    type: str
                type: dict
            type: list
        type: dict
      package_spec:
        description:
          - User provided package spec of the ReasoningEngine.
          - >-
            Ignored when users directly specify a deployment image through deploymentSpec.first_party_image_override, but keeping the field_behavior to

            avoid introducing breaking changes.
        suboptions:
          dependency_files_gcs_uri:
            description:
              - The Cloud Storage URI of the dependency files in tar.gz format.
            type: str
          pickle_object_gcs_uri:
            description:
              - The Cloud Storage URI of the pickled python object.
            type: str
          python_version:
            description:
              - The Python version.
              - Currently support 3.8, 3.9, 3.10, 3.11, 3.12, 3.13.
              - If not specified, default value is 3.10.
            type: str
          requirements_gcs_uri:
            description:
              - The Cloud Storage URI of the requirements.txtfile.
            type: str
        type: dict
      service_account:
        description:
          - The service account that the Reasoning Engine artifact runs as.
          - >-
            It should have "roles/storage.objectViewer" for reading the user project's Cloud Storage and "roles/aiplatform.user" for using Vertex

            extensions.
          - If not specified, the Vertex AI Reasoning Engine service Agent in the project will be used.
        type: str
      source_code_spec:
        description:
          - Specification for deploying from source code.
        suboptions:
          inline_source:
            description:
              - Source code is provided directly in the request.
            suboptions:
              source_archive:
                description:
                  - Input only.
                  - The application source code archive, provided as a compressed tarball (.tar.gz) file.
                  - A base64-encoded string.
                type: str
            type: dict
          python_spec:
            description:
              - Specification for running a Python application from source.
            suboptions:
              entrypoint_module:
                description:
                  - The Python module to load as the entrypoint, specified as a fully qualified module name.
                  - 'For example: path.to.agent.'
                  - If not specified, defaults to "agent".
                  - The project root will be added to Python sys.path, allowing imports to be specified relative to the root.
                type: str
              entrypoint_object:
                description:
                  - The name of the callable object within the entrypointModule to use as the application If not specified, defaults to "root_agent".
                type: str
              requirements_file:
                description:
                  - The path to the requirements file, relative to the source root.
                  - If not specified, defaults to "requirements.txt".
                type: str
              version:
                description:
                  - The version of Python to use.
                  - Support version includes 3.9, 3.10, 3.11, 3.12, 3.13.
                  - If not specified, default value is 3.10.
                type: str
            type: dict
        type: dict
    type: dict
  state:
    choices:
      - present
      - absent
    default: present
    description:
      - Whether the resource should exist in GCP.
    type: str
requirements:
  - python >= 3.8
  - requests >= 2.18.4
  - google-auth >= 2.25.1
short_description: Creates a GCP VertexAI.ReasoningEngine resource
"""

EXAMPLES = r"""
- name: Create Basic Reasoning Engine
  google.cloud.gcp_vertexai_reasoning_engine:
    state: present
    display_name: basic-reasoning-engine
    description: A Basic Reasoning Engine
    region: us-central1
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"

################################################################################

- name: Create Source Based Deployment Reasoning Engine
  google.cloud.gcp_vertexai_reasoning_engine:
    state: present
    display_name: source-based-deployment-reasoning-engine
    description: A Source Based Deployment Reasoning Engine
    region: us-central1
    spec:
      source_code_spec:
        inline_source:
          source_archive: "{{ slurped_tarball.content }}"  # slurp already returns b64
          # source_archive: "{{ some_other_b64_encoded_string }}"
        python_spec:
          entrypoint_module: my_agent
          entrypoint_object: name_generator
          requirements_file: prod-requirements.txt  # defaults to requirements.txt
          version: "3.11"
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"
"""

RETURN = r"""
changed:
  description: Whether the resource was changed.
  returned: always
  type: bool
createTime:
  description:
    - The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
  returned: success
  type: str
name:
  description:
    - The generated name of the ReasoningEngine, in the format projects/{project}/locations/{location}/reasoningEngines/{reasoningEngine}.
  returned: success
  type: str
state:
  description: The current state of the resource.
  returned: always
  type: str
updateTime:
  description:
    - The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
  returned: success
  type: str
"""

################################################################################
# Imports
################################################################################

from ansible_collections.google.cloud.plugins.module_utils import gcp_utils as gcp
import types

# BEGIN Custom imports

# END Custom imports


def build_link(module_params, uri):
    params = module_params.copy()

    return ("https://{region}-aiplatform.googleapis.com/v1/" + uri).format(**params)


class EncryptionSpec(gcp.Resource):
    def _request(self):
        return {
            "kmsKeyName": self.request.get("kms_key_name"),
        }

    def _response(self):
        return {
            "kmsKeyName": self.response.get("kmsKeyName"),
        }


class Spec(gcp.Resource):
    def _request(self):
        return {
            "agentFramework": self.request.get("agent_framework"),
            "classMethods": self.request.get("class_methods"),
            "deploymentSpec": gcp.remove_empties(
                SpecDeploymentSpec(self.request.get("deployment_spec", {})).to_request()
            ),  # remove empty values
            "packageSpec": gcp.remove_empties(
                SpecPackageSpec(self.request.get("package_spec", {})).to_request()
            ),  # remove empty values
            "serviceAccount": self.request.get("service_account"),
            "sourceCodeSpec": gcp.remove_empties(
                SpecSourceCodeSpec(self.request.get("source_code_spec", {})).to_request()
            ),  # remove empty values
        }

    def _response(self):
        return {
            "agentFramework": self.response.get("agentFramework"),
            "classMethods": self.response.get("classMethods"),
            "deploymentSpec": SpecDeploymentSpec().from_response(self.response.get("deploymentSpec", {})),
            "packageSpec": SpecPackageSpec().from_response(self.response.get("packageSpec", {})),
            "serviceAccount": self.response.get("serviceAccount"),
            "sourceCodeSpec": SpecSourceCodeSpec().from_response(self.response.get("sourceCodeSpec", {})),
        }


class SpecDeploymentSpec(gcp.Resource):
    def _request(self):
        return {
            "containerConcurrency": self.request.get("container_concurrency"),
            "env": [SpecDeploymentSpecEnv(item).to_request() for item in (self.request.get("env") or [])],
            "maxInstances": self.request.get("max_instances"),
            "minInstances": self.request.get("min_instances"),
            "pscInterfaceConfig": gcp.remove_empties(
                SpecDeploymentSpecPscInterfaceConfig(self.request.get("psc_interface_config", {})).to_request()
            ),  # remove empty values
            "resourceLimits": self.request.get("resource_limits"),
            "secretEnv": [
                SpecDeploymentSpecSecretEnv(item).to_request() for item in (self.request.get("secret_env") or [])
            ],
        }

    def _response(self):
        return {
            "containerConcurrency": self.response.get("containerConcurrency"),
            "env": [SpecDeploymentSpecEnv().from_response(item) for item in (self.response.get("env") or [])],
            "maxInstances": self.response.get("maxInstances"),
            "minInstances": self.response.get("minInstances"),
            "pscInterfaceConfig": SpecDeploymentSpecPscInterfaceConfig().from_response(
                self.response.get("pscInterfaceConfig", {})
            ),
            "resourceLimits": self.response.get("resourceLimits"),
            "secretEnv": [
                SpecDeploymentSpecSecretEnv().from_response(item) for item in (self.response.get("secretEnv") or [])
            ],
        }


class SpecDeploymentSpecEnv(gcp.Resource):
    def _request(self):
        return {
            "name": self.request.get("name"),
            "value": self.request.get("value"),
        }

    def _response(self):
        return {
            "name": self.response.get("name"),
            "value": self.response.get("value"),
        }


class SpecDeploymentSpecPscInterfaceConfig(gcp.Resource):
    def _request(self):
        return {
            "dnsPeeringConfigs": [
                SpecDeploymentSpecPscInterfaceConfigDnsPeeringConfig(item).to_request()
                for item in (self.request.get("dns_peering_configs") or [])
            ],
            "networkAttachment": self.request.get("network_attachment"),
        }

    def _response(self):
        return {
            "dnsPeeringConfigs": [
                SpecDeploymentSpecPscInterfaceConfigDnsPeeringConfig().from_response(item)
                for item in (self.response.get("dnsPeeringConfigs") or [])
            ],
            "networkAttachment": self.response.get("networkAttachment"),
        }


class SpecDeploymentSpecPscInterfaceConfigDnsPeeringConfig(gcp.Resource):
    def _request(self):
        return {
            "domain": self.request.get("domain"),
            "targetNetwork": self.request.get("target_network"),
            "targetProject": self.request.get("target_project"),
        }

    def _response(self):
        return {
            "domain": self.response.get("domain"),
            "targetNetwork": self.response.get("targetNetwork"),
            "targetProject": self.response.get("targetProject"),
        }


class SpecDeploymentSpecSecretEnv(gcp.Resource):
    def _request(self):
        return {
            "name": self.request.get("name"),
            "secretRef": gcp.remove_empties(
                SpecDeploymentSpecSecretEnvSecretRef(self.request.get("secret_ref", {})).to_request()
            ),  # remove empty values
        }

    def _response(self):
        return {
            "name": self.response.get("name"),
            "secretRef": SpecDeploymentSpecSecretEnvSecretRef().from_response(self.response.get("secretRef", {})),
        }


class SpecDeploymentSpecSecretEnvSecretRef(gcp.Resource):
    def _request(self):
        return {
            "secret": self.request.get("secret"),
            "version": self.request.get("version"),
        }

    def _response(self):
        return {
            "secret": self.response.get("secret"),
            "version": self.response.get("version"),
        }


class SpecPackageSpec(gcp.Resource):
    def _request(self):
        return {
            "dependencyFilesGcsUri": self.request.get("dependency_files_gcs_uri"),
            "pickleObjectGcsUri": self.request.get("pickle_object_gcs_uri"),
            "pythonVersion": self.request.get("python_version"),
            "requirementsGcsUri": self.request.get("requirements_gcs_uri"),
        }

    def _response(self):
        return {
            "dependencyFilesGcsUri": self.response.get("dependencyFilesGcsUri"),
            "pickleObjectGcsUri": self.response.get("pickleObjectGcsUri"),
            "pythonVersion": self.response.get("pythonVersion"),
            "requirementsGcsUri": self.response.get("requirementsGcsUri"),
        }


class SpecSourceCodeSpec(gcp.Resource):
    def _request(self):
        return {
            "inlineSource": gcp.remove_empties(
                SpecSourceCodeSpecInlineSource(self.request.get("inline_source", {})).to_request()
            ),  # remove empty values
            "pythonSpec": gcp.remove_empties(
                SpecSourceCodeSpecPythonSpec(self.request.get("python_spec", {})).to_request()
            ),  # remove empty values
        }

    def _response(self):
        return {
            "inlineSource": SpecSourceCodeSpecInlineSource().from_response(self.response.get("inlineSource", {})),
            "pythonSpec": SpecSourceCodeSpecPythonSpec().from_response(self.response.get("pythonSpec", {})),
        }


class SpecSourceCodeSpecInlineSource(gcp.Resource):
    def _request(self):
        return {
            "sourceArchive": self.request.get("source_archive"),
        }

    def _response(self):
        return {
            "sourceArchive": self.response.get("sourceArchive"),
        }


class SpecSourceCodeSpecPythonSpec(gcp.Resource):
    def _request(self):
        return {
            "entrypointModule": self.request.get("entrypoint_module"),
            "entrypointObject": self.request.get("entrypoint_object"),
            "requirementsFile": self.request.get("requirements_file"),
            "version": self.request.get("version"),
        }

    def _response(self):
        return {
            "entrypointModule": self.response.get("entrypointModule"),
            "entrypointObject": self.response.get("entrypointObject"),
            "requirementsFile": self.response.get("requirementsFile"),
            "version": self.response.get("version"),
        }


class VertexAI(gcp.Resource):
    def _request(self):
        return {
            "description": self.request.get("description"),
            "displayName": self.request.get("display_name"),
            "encryptionSpec": gcp.remove_empties(
                EncryptionSpec(self.request.get("encryption_spec", {})).to_request()
            ),  # remove empty values
            "spec": gcp.remove_empties(Spec(self.request.get("spec", {})).to_request()),  # remove empty values
        }

    def _response(self):
        return {
            "createTime": self.response.get("createTime"),
            "description": self.response.get("description"),
            "displayName": self.response.get("displayName"),
            "encryptionSpec": EncryptionSpec().from_response(self.response.get("encryptionSpec", {})),
            "name": self.response.get("name"),
            "spec": Spec().from_response(self.response.get("spec", {})),
            "updateTime": self.response.get("updateTime"),
        }


################################################################################
# Main
################################################################################


def encode(self, obj):
    """
    This is a function bound to the main resource object. Its input is the object returned from to_request()
    and it mutates it before it is sent to the API.
    """
    return obj


def decode(self, obj):
    """
    This is a function bound to the main resource object. Its input is the object returned from from_response()
    and it mutates it before it is returned to the module caller.
    """
    return obj


def main():
    """Main function"""

    module = gcp.Module(
        argument_spec=dict(
            state=dict(
                type="str",
                default="present",
                choices=["present", "absent"],
            ),
            description=dict(
                type="str",
            ),
            display_name=dict(
                type="str",
                required=True,
            ),
            encryption_spec=dict(
                type="dict",
                options=dict(
                    kms_key_name=dict(
                        type="str",
                        required=True,
                        no_log=False,
                    )
                ),
            ),
            region=dict(
                type="str",
            ),
            spec=dict(
                type="dict",
                options=dict(
                    agent_framework=dict(
                        type="str",
                    ),
                    class_methods=dict(
                        type="str",
                    ),
                    deployment_spec=dict(
                        type="dict",
                        options=dict(
                            container_concurrency=dict(
                                type="int",
                            ),
                            env=dict(
                                type="list",
                                elements="dict",
                                options=dict(
                                    name=dict(
                                        type="str",
                                        required=True,
                                    ),
                                    value=dict(
                                        type="str",
                                        required=True,
                                    ),
                                ),
                            ),
                            max_instances=dict(
                                type="int",
                            ),
                            min_instances=dict(
                                type="int",
                            ),
                            psc_interface_config=dict(
                                type="dict",
                                options=dict(
                                    dns_peering_configs=dict(
                                        type="list",
                                        elements="dict",
                                        options=dict(
                                            domain=dict(
                                                type="str",
                                                required=True,
                                            ),
                                            target_network=dict(
                                                type="str",
                                                required=True,
                                            ),
                                            target_project=dict(
                                                type="str",
                                                required=True,
                                            ),
                                        ),
                                    ),
                                    network_attachment=dict(
                                        type="str",
                                    ),
                                ),
                            ),
                            resource_limits=dict(
                                type="dict",
                            ),
                            secret_env=dict(
                                type="list",
                                elements="dict",
                                no_log=False,
                                options=dict(
                                    name=dict(
                                        type="str",
                                        required=True,
                                    ),
                                    secret_ref=dict(
                                        type="dict",
                                        required=True,
                                        no_log=False,
                                        options=dict(
                                            secret=dict(
                                                type="str",
                                                required=True,
                                                no_log=False,
                                            ),
                                            version=dict(
                                                type="str",
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    package_spec=dict(
                        type="dict",
                        options=dict(
                            dependency_files_gcs_uri=dict(
                                type="str",
                            ),
                            pickle_object_gcs_uri=dict(
                                type="str",
                            ),
                            python_version=dict(
                                type="str",
                            ),
                            requirements_gcs_uri=dict(
                                type="str",
                            ),
                        ),
                    ),
                    service_account=dict(
                        type="str",
                    ),
                    source_code_spec=dict(
                        type="dict",
                        options=dict(
                            inline_source=dict(
                                type="dict",
                                options=dict(
                                    source_archive=dict(
                                        type="str",
                                    )
                                ),
                            ),
                            python_spec=dict(
                                type="dict",
                                options=dict(
                                    entrypoint_module=dict(
                                        type="str",
                                    ),
                                    entrypoint_object=dict(
                                        type="str",
                                    ),
                                    requirements_file=dict(
                                        type="str",
                                    ),
                                    version=dict(
                                        type="str",
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        )
    )

    if not module.params["scopes"]:
        module.params["scopes"] = ["https://www.googleapis.com/auth/cloud-platform"]

    state = module.params["state"]
    changed = False
    op_configs = gcp.ResourceOpConfigs(
        {
            "base_url": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/reasoningEngines",
                    "async_uri": "",
                    "verb": "GET",
                    "timeout_minutes": 0,
                }
            ),
            "create": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/reasoningEngines",
                    "async_uri": "{op_id}",
                    "verb": "POST",
                    "timeout_minutes": 20,
                }
            ),
            "delete": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/reasoningEngines/{name}",
                    "async_uri": "{op_id}",
                    "verb": "DELETE",
                    "timeout_minutes": 60,
                }
            ),
            "read": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/reasoningEngines/{name}",
                    "async_uri": "",
                    "verb": "GET",
                    "timeout_minutes": 0,
                }
            ),
            "update": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/reasoningEngines/{name}",
                    "async_uri": "{op_id}",
                    "verb": "PATCH",
                    "timeout_minutes": 20,
                }
            ),
        }
    )

    params = gcp.remove_nones(module.params)
    resource = VertexAI(params, module=module, product="VertexAI", kind="vertexai#reasoningEngine")
    read_uri = op_configs.read.uri

    resource._state = state  # store the state in the resource object
    # Bind the encode and decode functions to the resource object
    resource.encode_func = types.MethodType(encode, resource)
    resource.decode_func = types.MethodType(decode, resource)

    custom_diff = None  # Set this variable if you want to implement custom diff logic

    # --------- BEGIN pre-read custom code ---------
    # for this module, we're hitting the list endpoint and filtering on display name
    read_uri = f"{op_configs.base_url.uri}?filter=displayName={params.get("display_name")}"

    # --------- END pre-read custom code ---------

    read_url = build_link(params, read_uri)
    existing_obj = resource.get(read_url, allow_not_found=True) or {}
    new_obj = {}
    gcp.debug(module, existing=existing_obj, post=False)

    # --------- BEGIN post-read custom code ---------
    if not gcp.empty(existing_obj):
        for rengine in existing_obj.get("reasoningEngines", []):
            if rengine.get("displayName") == params.get("display_name"):
                existing_obj = rengine
                break

    # --------- END post-read custom code ---------

    if custom_diff is not None:
        is_different = custom_diff
    else:
        is_different = resource.diff(gcp.remove_empties(existing_obj))
    gcp.debug(
        module,
        request=gcp.remove_empties(resource.to_request()),
        existing=existing_obj,
        post=True,
        is_different=is_different,
    )

    if gcp.empty(existing_obj):
        if state == "present":
            create_uri = op_configs.create.uri
            create_async_uri = op_configs.create.async_uri
            try:
                # --------- BEGIN create code ---------
                is_async = create_async_uri != ""
                create_link = build_link(params, create_uri)
                create_retries = op_configs.create.timeout
                create_func = getattr(resource, op_configs.create.verb)
                async_create_func = getattr(resource, op_configs.create.verb + "_async")
                async_create_link = build_link(params, "") + create_async_uri
                gcp.debug(
                    module,
                    msg="Creating resource",
                    create_link=create_link,
                    async_create_link=async_create_link,
                    is_async=is_async,
                )

                if is_async:
                    new_obj = async_create_func(create_link, async_link=async_create_link, retries=create_retries)
                else:
                    new_obj = create_func(create_link)
                gcp.debug(module, new=new_obj, action="create", post=False)
                gcp.debug(module, new=new_obj, action="create", post=True)
                # --------- END create code ---------
            except Exception as e:
                module.fail_json(msg=str(e))

            changed = True
        else:
            pass  # nothing to do
    else:
        if state == "absent":
            delete_uri = op_configs.delete.uri
            delete_async_uri = op_configs.delete.async_uri
            try:
                # --------- BEGIN delete code ---------
                # --------- BEGIN pre-delete custom code ---------
                # need to set to the required parameter "name" to the existing resource name
                params["name"] = existing_obj["name"].split("/")[-1]

                # --------- END pre-delete custom code ---------
                is_async = delete_async_uri != ""
                delete_link = build_link(params, delete_uri)
                delete_retries = op_configs.delete.timeout
                delete_func = getattr(resource, op_configs.delete.verb)
                async_delete_func = getattr(resource, op_configs.delete.verb + "_async")
                async_delete_link = build_link(params, "") + delete_async_uri
                gcp.debug(
                    module,
                    msg="Destroying resource",
                    delete_link=delete_link,
                    async_delete_link=async_delete_link,
                    is_async=is_async,
                )
                if is_async:
                    new_obj = async_delete_func(delete_link, async_link=async_delete_link, retries=delete_retries)
                else:
                    new_obj = delete_func(delete_link)
                # --------- END delete code ---------
            except Exception as e:
                module.fail_json(msg=str(e))

            changed = True
        else:
            if is_different:
                update_uri = op_configs.update.uri
                update_async_uri = op_configs.update.async_uri
                try:
                    # --------- BEGIN update code ---------
                    # --------- BEGIN pre-update custom code ---------
                    # need to set to the required parameter "name" to the existing resource name
                    params["name"] = existing_obj["name"].split("/")[-1]

                    # finally, need to build the updateMask for the fields in our module
                    update_uri += f"?updateMask={','.join(resource.dot_fields())}"

                    # --------- END pre-update custom code ---------
                    is_async = update_async_uri != ""
                    update_link = build_link(params, update_uri)
                    update_retries = op_configs.update.timeout
                    update_func = getattr(resource, op_configs.update.verb)
                    async_update_func = getattr(resource, op_configs.update.verb + "_async")
                    async_update_link = build_link(params, "") + update_async_uri
                    gcp.debug(
                        module,
                        msg="Updating resource",
                        update_link=update_link,
                        async_update_link=async_update_link,
                        is_async=is_async,
                    )
                    if is_async:
                        new_obj = async_update_func(update_link, async_link=async_update_link, retries=update_retries)
                    else:
                        new_obj = update_func(update_link)
                    gcp.debug(module, new=new_obj, action="update", post=False)
                    gcp.debug(module, new=new_obj, action="update", post=True)
                    # --------- END update code ---------
                except Exception as e:
                    module.fail_json(msg=str(e))

                changed = True
            else:
                new_obj = existing_obj

    new_obj.update({"changed": changed})
    module.exit_json(**new_obj)


if __name__ == "__main__":
    main()
