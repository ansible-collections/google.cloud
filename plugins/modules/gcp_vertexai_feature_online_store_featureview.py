#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2017-2026 Google
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This file is automatically generated by Magic Modules and manual
#     changes will be clobbered when the file is regenerated.
#
# ----------------------------------------------------------------------------
#

from __future__ import absolute_import, division, print_function

__metaclass__ = type

################################################################################
# Documentation
################################################################################

ANSIBLE_METADATA = {
    "metadata_version": "1.1",
    "status": ["preview"],
    "supported_by": "community",
}

DOCUMENTATION = r"""
---
author:
  - Google Inc. (@googlecloudplatform)
description:
  - FeatureView is representation of values that the FeatureOnlineStore will serve based on its syncConfig.
extends_documentation_fragment:
  - google.cloud.gcp
module: gcp_vertexai_feature_online_store_featureview
notes:
  - 'API Reference: U(https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.featureOnlineStores.featureViews)'
  - 'Official Documentation Guide: U(https://cloud.google.com/vertex-ai/docs)'
options:
  big_query_source:
    description:
      - Configures how data is supposed to be extracted from a BigQuery source to be loaded onto the FeatureOnlineStore.
    suboptions:
      entity_id_columns:
        description:
          - Columns to construct entityId / row keys.
          - Start by supporting 1 only.
        elements: str
        required: true
        type: list
      uri:
        description:
          - The BigQuery view URI that will be materialized on each sync trigger based on FeatureView.SyncConfig.
        required: true
        type: str
    type: dict
  feature_online_store:
    description:
      - The name of the FeatureOnlineStore to use for the featureview.
    required: true
    type: str
  feature_registry_source:
    description:
      - Configures the features from a Feature Registry source that need to be loaded onto the FeatureOnlineStore.
    suboptions:
      feature_groups:
        description:
          - List of features that need to be synced to Online Store.
        elements: dict
        required: true
        suboptions:
          feature_group_id:
            description:
              - Identifier of the feature group.
            required: true
            type: str
          feature_ids:
            description:
              - Identifiers of features under the feature group.
            elements: str
            required: true
            type: list
        type: list
      project_number:
        description:
          - The project number of the parent project of the feature Groups.
        type: str
    type: dict
  labels:
    description:
      - A set of key/value label pairs to assign to this FeatureView.
    type: dict
  name:
    description:
      - Name of the FeatureView.
      - This value may be up to 60 characters, and valid characters are [a-z0-9_].
      - The first character cannot be a number.
    type: str
  region:
    description:
      - The region for the resource.
      - It should be the same as the featureonlinestore region.
    required: true
    type: str
  state:
    choices:
      - present
      - absent
    default: present
    description:
      - Whether the resource should exist in GCP.
    type: str
  sync_config:
    description:
      - Configures when data is to be synced/updated for this FeatureView.
      - At the end of the sync the latest featureValues for each entityId of this FeatureView are made ready for online serving.
    suboptions:
      continuous:
        description:
          - If true, syncs the FeatureView in a continuous manner to Online Store.
        type: bool
      cron:
        description:
          - Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
          - 'To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".'
        type: str
    type: dict
  vector_search_config:
    description:
      - Configuration for vector search.
      - It contains the required configurations to create an index from source data, so that approximate nearest neighbor (a.k.a ANN) algorithms search can be performed during online serving.
    suboptions:
      brute_force_config:
        description:
          - Configuration options for using brute force search, which simply implements the standard linear search in the database for each query.
          - It is primarily meant for benchmarking and to generate the ground truth for approximate search.
        type: dict
      crowding_column:
        description:
          - Column of crowding.
          - This column contains crowding attribute which is a constraint on a neighbor list produced by nearest neighbor search requiring that no more than some value k' of the k neighbors returned have the same value of crowdingAttribute.
        type: str
      distance_measure_type:
        choices:
          - SQUARED_L2_DISTANCE
          - COSINE_DISTANCE
          - DOT_PRODUCT_DISTANCE
        description:
          - The distance measure used in nearest neighbor search.
          - For details on allowed values, see the [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.featureOnlineStores.featureViews#DistanceMeasureType).
        type: str
      embedding_column:
        description:
          - Column of embedding.
          - This column contains the source data to create index for vector search.
        required: true
        type: str
      embedding_dimension:
        description:
          - The number of dimensions of the input embedding.
        type: int
      filter_columns:
        description:
          - Columns of features that are used to filter vector search results.
        elements: str
        type: list
      tree_ah_config:
        description:
          - Configuration options for the tree-AH algorithm (Shallow tree + Asymmetric Hashing).
          - 'Please refer to this paper for more details: https://arxiv.org/abs/1908.10396.'
        suboptions:
          leaf_node_embedding_count:
            description:
              - Number of embeddings on each leaf node.
              - The default value is 1000 if not set.
            type: str
        type: dict
    type: dict
requirements:
  - python >= 3.8
  - requests >= 2.18.4
  - google-auth >= 2.25.1
short_description: Creates a GCP VertexAI.FeatureOnlineStoreFeatureview resource
"""  # noqa: E501

EXAMPLES = r"""
- name: Create Feature Online Store Featureview
  google.cloud.gcp_vertexai_feature_online_store_featureview:
    state: present
    name: my_feature_online_store_featureview
    feature_online_store: my_feature_online_store
    sync_config:
      cron: "0 0 * * *"
    big_query_source:
      uri: "bq://{{ gcp_project }}.my_dataset.my_table"
    region: us-central1
    project: "{{ gcp_project }}"
    auth_kind: "{{ gcp_cred_kind }}"
    service_account_file: "{{ gcp_cred_file }}"
"""  # noqa: E501

RETURN = r"""
changed:
  description: Whether the resource was changed.
  returned: always
  type: bool
createTime:
  description:
    - The timestamp of when the featureOnlinestore was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
  returned: success
  type: str
state:
  description: The current state of the resource.
  returned: always
  type: str
updateTime:
  description:
    - The timestamp of when the featureOnlinestore was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
  returned: success
  type: str
"""  # noqa: E501

################################################################################
# Imports
################################################################################

from ansible_collections.google.cloud.plugins.module_utils import gcp_utils as gcp
import types

# BEGIN Custom imports

# END Custom imports


def build_link(module_params, uri):
    params = module_params.copy()

    return ("https://{region}-aiplatform.googleapis.com/v1/" + uri).format(**params)


class BigQuerySource(gcp.Resource):
    def _request(self):
        return {
            "entityIdColumns": self.request.get("entity_id_columns"),
            "uri": self.request.get("uri"),
        }

    def _response(self):
        return {
            "entityIdColumns": self.response.get("entityIdColumns"),
            "uri": self.response.get("uri"),
        }


class FeatureRegistrySource(gcp.Resource):
    def _request(self):
        return {
            "featureGroups": [
                FeatureRegistrySourceFeatureGroup(item).to_request()
                for item in (self.request.get("feature_groups") or [])
            ],
            "projectNumber": self.request.get("project_number"),
        }

    def _response(self):
        return {
            "featureGroups": [
                FeatureRegistrySourceFeatureGroup().from_response(item)
                for item in (self.response.get("featureGroups") or [])
            ],
            "projectNumber": self.response.get("projectNumber"),
        }


class FeatureRegistrySourceFeatureGroup(gcp.Resource):
    def _request(self):
        return {
            "featureGroupId": self.request.get("feature_group_id"),
            "featureIds": self.request.get("feature_ids"),
        }

    def _response(self):
        return {
            "featureGroupId": self.response.get("featureGroupId"),
            "featureIds": self.response.get("featureIds"),
        }


class SyncConfig(gcp.Resource):
    def _request(self):
        return {
            "continuous": self.request.get("continuous"),
            "cron": self.request.get("cron"),
        }

    def _response(self):
        return {
            "continuous": self.response.get("continuous"),
            "cron": self.response.get("cron"),
        }


class VectorSearchConfig(gcp.Resource):
    def _request(self):
        return {
            "bruteForceConfig": gcp.remove_nones(
                VectorSearchConfigBruteForceConfig(self.request.get("brute_force_config", {})).to_request()
            ),  # allow empty values
            "crowdingColumn": self.request.get("crowding_column"),
            "distanceMeasureType": self.request.get("distance_measure_type"),
            "embeddingColumn": self.request.get("embedding_column"),
            "embeddingDimension": self.request.get("embedding_dimension"),
            "filterColumns": self.request.get("filter_columns"),
            "treeAhConfig": gcp.remove_empties(
                VectorSearchConfigTreeAhConfig(self.request.get("tree_ah_config", {})).to_request()
            ),  # remove empty values
        }

    def _response(self):
        return {
            "bruteForceConfig": VectorSearchConfigBruteForceConfig().from_response(
                self.response.get("bruteForceConfig", {})
            ),
            "crowdingColumn": self.response.get("crowdingColumn"),
            "distanceMeasureType": self.response.get("distanceMeasureType"),
            "embeddingColumn": self.response.get("embeddingColumn"),
            "embeddingDimension": self.response.get("embeddingDimension"),
            "filterColumns": self.response.get("filterColumns"),
            "treeAhConfig": VectorSearchConfigTreeAhConfig().from_response(self.response.get("treeAhConfig", {})),
        }


class VectorSearchConfigBruteForceConfig(gcp.Resource):
    def _request(self):
        return self.request.get("brute_force_config", dict())

    def _response(self):
        return self.response.get("brute_force_config", dict())


class VectorSearchConfigTreeAhConfig(gcp.Resource):
    def _request(self):
        return {
            "leafNodeEmbeddingCount": self.request.get("leaf_node_embedding_count"),
        }

    def _response(self):
        return {
            "leafNodeEmbeddingCount": self.response.get("leafNodeEmbeddingCount"),
        }


class VertexAI(gcp.Resource):
    def _request(self):
        return {
            "bigQuerySource": gcp.remove_empties(
                BigQuerySource(self.request.get("big_query_source", {})).to_request()
            ),  # remove empty values
            "featureRegistrySource": gcp.remove_empties(
                FeatureRegistrySource(self.request.get("feature_registry_source", {})).to_request()
            ),  # remove empty values
            "labels": self.request.get("labels"),
            "syncConfig": gcp.remove_empties(
                SyncConfig(self.request.get("sync_config", {})).to_request()
            ),  # remove empty values
            "vectorSearchConfig": gcp.remove_empties(
                VectorSearchConfig(self.request.get("vector_search_config", {})).to_request()
            ),  # remove empty values
        }

    def _response(self):
        return {
            "bigQuerySource": BigQuerySource().from_response(self.response.get("bigQuerySource", {})),
            "createTime": self.response.get("createTime"),
            "featureRegistrySource": FeatureRegistrySource().from_response(
                self.response.get("featureRegistrySource", {})
            ),
            "labels": self.response.get("labels"),
            "syncConfig": SyncConfig().from_response(self.response.get("syncConfig", {})),
            "updateTime": self.response.get("updateTime"),
            "vectorSearchConfig": VectorSearchConfig().from_response(self.response.get("vectorSearchConfig", {})),
        }


################################################################################
# Main
################################################################################


def encode(self, obj):
    """
    This is a function bound to the main resource object. Its input is the object returned from to_request()
    and it mutates it before it is sent to the API.
    """
    return obj


def decode(self, obj):
    """
    This is a function bound to the main resource object. Its input is the object returned from from_response()
    and it mutates it before it is returned to the module caller.
    """
    return obj


def main():
    """Main function"""

    module = gcp.Module(
        argument_spec=dict(
            name=dict(
                type="str",
            ),
            state=dict(
                type="str",
                default="present",
                choices=["present", "absent"],
            ),
            big_query_source=dict(
                type="dict",
                options=dict(
                    entity_id_columns=dict(
                        type="list",
                        required=True,
                        elements="str",
                    ),
                    uri=dict(
                        type="str",
                        required=True,
                    ),
                ),
            ),
            feature_online_store=dict(
                type="str",
                required=True,
            ),
            feature_registry_source=dict(
                type="dict",
                options=dict(
                    feature_groups=dict(
                        type="list",
                        required=True,
                        elements="dict",
                        options=dict(
                            feature_group_id=dict(
                                type="str",
                                required=True,
                            ),
                            feature_ids=dict(
                                type="list",
                                required=True,
                                elements="str",
                            ),
                        ),
                    ),
                    project_number=dict(
                        type="str",
                    ),
                ),
            ),
            labels=dict(
                type="dict",
            ),
            region=dict(
                type="str",
                required=True,
            ),
            sync_config=dict(
                type="dict",
                options=dict(
                    continuous=dict(
                        type="bool",
                    ),
                    cron=dict(
                        type="str",
                    ),
                ),
                mutually_exclusive=[["continuous", "cron"]],
            ),
            vector_search_config=dict(
                type="dict",
                options=dict(
                    brute_force_config=dict(
                        type="dict",
                    ),
                    crowding_column=dict(
                        type="str",
                    ),
                    distance_measure_type=dict(
                        type="str",
                        choices=["SQUARED_L2_DISTANCE", "COSINE_DISTANCE", "DOT_PRODUCT_DISTANCE"],
                    ),
                    embedding_column=dict(
                        type="str",
                        required=True,
                    ),
                    embedding_dimension=dict(
                        type="int",
                    ),
                    filter_columns=dict(
                        type="list",
                        elements="str",
                    ),
                    tree_ah_config=dict(
                        type="dict",
                        options=dict(
                            leaf_node_embedding_count=dict(
                                type="str",
                            )
                        ),
                    ),
                ),
                mutually_exclusive=[["brute_force_config", "tree_ah_config"]],
                required_one_of=[["brute_force_config", "tree_ah_config"]],
            ),
        ),
        mutually_exclusive=[
            ["big_query_source", "feature_registry_source"],
            ["feature_registry_source", "vector_search_config"],
        ],
        required_one_of=[["big_query_source", "feature_registry_source"]],
    )

    if not module.params["scopes"]:
        module.params["scopes"] = ["https://www.googleapis.com/auth/cloud-platform"]

    state = module.params["state"]
    changed = False
    op_configs = gcp.ResourceOpConfigs(
        {
            "base_url": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/featureOnlineStores/{feature_online_store}/featureViews",
                    "async_uri": "",
                    "verb": "GET",
                    "timeout_minutes": 0,
                }
            ),
            "create": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/featureOnlineStores/{feature_online_store}/featureViews?featureViewId={name}",
                    "async_uri": "{op_id}",
                    "verb": "POST",
                    "timeout_minutes": 20,
                }
            ),
            "delete": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/featureOnlineStores/{feature_online_store}/featureViews/{name}",
                    "async_uri": "{op_id}",
                    "verb": "DELETE",
                    "timeout_minutes": 20,
                }
            ),
            "read": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/featureOnlineStores/{feature_online_store}/featureViews/{name}",
                    "async_uri": "",
                    "verb": "GET",
                    "timeout_minutes": 0,
                }
            ),
            "update": gcp.ResourceOpConfig(
                **{
                    "uri": "projects/{project}/locations/{region}/featureOnlineStores/{feature_online_store}/featureViews/{name}",
                    "async_uri": "",
                    "verb": "PATCH",
                    "timeout_minutes": 20,
                }
            ),
        }
    )

    params = gcp.remove_nones(module.params)
    resource = VertexAI(params, module=module, product="VertexAI", kind="vertexai#featureOnlineStoreFeatureview")
    read_uri = op_configs.read.uri

    resource._state = state  # store the state in the resource object
    # Bind the encode and decode functions to the resource object
    resource.encode_func = types.MethodType(encode, resource)
    resource.decode_func = types.MethodType(decode, resource)

    custom_diff = None  # Set this variable if you want to implement custom diff logic

    read_url = build_link(params, read_uri)
    existing_obj = resource.get(read_url, allow_not_found=True) or {}
    new_obj = {}
    gcp.debug(module, existing=existing_obj, post=False)

    if custom_diff is not None:
        is_different = custom_diff
    else:
        is_different = resource.diff(gcp.remove_empties(existing_obj))
    gcp.debug(
        module,
        request=gcp.remove_empties(resource.to_request()),
        existing=existing_obj,
        post=True,
        is_different=is_different,
    )

    if gcp.empty(existing_obj):
        if state == "present":
            create_uri = op_configs.create.uri
            create_async_uri = op_configs.create.async_uri
            try:
                # --------- BEGIN create code ---------
                is_async = create_async_uri != ""
                create_link = build_link(params, create_uri)
                create_retries = op_configs.create.timeout
                create_func = getattr(resource, op_configs.create.verb)
                async_create_func = getattr(resource, op_configs.create.verb + "_async")
                async_create_link = build_link(params, "") + create_async_uri
                gcp.debug(
                    module,
                    msg="Creating resource",
                    create_link=create_link,
                    async_create_link=async_create_link,
                    is_async=is_async,
                )

                if is_async:
                    new_obj = async_create_func(create_link, async_link=async_create_link, retries=create_retries)
                else:
                    new_obj = create_func(create_link)
                gcp.debug(module, new=new_obj, action="create", post=False)
                gcp.debug(module, new=new_obj, action="create", post=True)
                # --------- END create code ---------
            except Exception as e:
                module.fail_json(msg=str(e))

            changed = True
        else:
            pass  # nothing to do
    else:
        if state == "absent":
            delete_uri = op_configs.delete.uri
            delete_async_uri = op_configs.delete.async_uri
            try:
                # --------- BEGIN delete code ---------
                is_async = delete_async_uri != ""
                delete_link = build_link(params, delete_uri)
                delete_retries = op_configs.delete.timeout
                delete_func = getattr(resource, op_configs.delete.verb)
                async_delete_func = getattr(resource, op_configs.delete.verb + "_async")
                async_delete_link = build_link(params, "") + delete_async_uri
                gcp.debug(
                    module,
                    msg="Destroying resource",
                    delete_link=delete_link,
                    async_delete_link=async_delete_link,
                    is_async=is_async,
                )
                if is_async:
                    new_obj = async_delete_func(delete_link, async_link=async_delete_link, retries=delete_retries)
                else:
                    new_obj = delete_func(delete_link)
                # --------- END delete code ---------
            except Exception as e:
                module.fail_json(msg=str(e))

            changed = True
        else:
            if is_different:
                update_uri = op_configs.update.uri
                update_async_uri = op_configs.update.async_uri
                try:
                    # --------- BEGIN update code ---------
                    is_async = update_async_uri != ""
                    update_link = build_link(params, update_uri)
                    update_retries = op_configs.update.timeout
                    update_func = getattr(resource, op_configs.update.verb)
                    async_update_func = getattr(resource, op_configs.update.verb + "_async")
                    async_update_link = build_link(params, "") + update_async_uri
                    gcp.debug(
                        module,
                        msg="Updating resource",
                        update_link=update_link,
                        async_update_link=async_update_link,
                        is_async=is_async,
                    )
                    if is_async:
                        new_obj = async_update_func(update_link, async_link=async_update_link, retries=update_retries)
                    else:
                        new_obj = update_func(update_link)
                    gcp.debug(module, new=new_obj, action="update", post=False)
                    gcp.debug(module, new=new_obj, action="update", post=True)
                    # --------- END update code ---------
                except Exception as e:
                    module.fail_json(msg=str(e))

                changed = True
            else:
                new_obj = existing_obj

    new_obj.update({"changed": changed})
    module.exit_json(**new_obj)


if __name__ == "__main__":
    main()
